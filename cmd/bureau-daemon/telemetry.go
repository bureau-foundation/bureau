// Copyright 2026 The Bureau Authors
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"context"
	"time"

	"github.com/bureau-foundation/bureau/lib/ref"
	"github.com/bureau-foundation/bureau/lib/schema"
	"github.com/bureau-foundation/bureau/lib/schema/telemetry"
	"github.com/bureau-foundation/bureau/lib/service"
	"github.com/bureau-foundation/bureau/lib/servicetoken"
	"github.com/bureau-foundation/bureau/messaging"
)

// telemetryServiceRole is the token audience for telemetry services.
// Both the telemetry relay and the telemetry service bootstrap with
// this audience, so tokens minted with this audience are accepted by
// either. Used for proxy telemetry tokens and complete-log tokens.
const telemetryServiceRole = "telemetry"

// telemetryRelayRole is the service binding key for the per-machine
// telemetry relay. When a relay is deployed, the config room has a
// "telemetry-relay" binding pointing to it. The relay's
// RequiredServices: ["telemetry"] separately resolves the "telemetry"
// binding to find the upstream telemetry service — no circular
// dependency because the two binding keys are distinct.
const telemetryRelayRole = "telemetry-relay"

// resolveTelemetrySocket looks up the telemetry binding in the
// machine's config room and returns the host-side socket path for
// output capture and complete-log. Checks two bindings in order:
//
//  1. "telemetry-relay" — the per-machine relay (preferred when
//     deployed, because sandboxes submit output to it and
//     complete-log must flush the relay's buffer first).
//  2. "telemetry" — the telemetry service directly (used when no
//     relay is deployed, e.g., mock deployments in tests).
//
// Returns an empty string if neither binding exists (telemetry not
// deployed) or if resolution fails (logged as a warning — not a
// fatal condition). Telemetry is an optional enhancement.
//
// Caches the result in d.telemetrySocketPath so the token refresh
// loop can include the telemetry role without re-resolving the
// binding. The caller must hold reconcileMu (which reconcile()
// always does).
func (d *Daemon) resolveTelemetrySocket(ctx context.Context) string {
	// Try the relay binding first. When the relay is deployed,
	// sandboxes submit output to it and complete-log must go through
	// it to flush buffered data before the service marks the session
	// complete.
	binding, err := messaging.GetState[schema.ServiceBindingContent](ctx, d.session, d.configRoomID, schema.EventTypeServiceBinding, telemetryRelayRole)
	if err != nil {
		if !messaging.IsMatrixError(err, messaging.ErrCodeNotFound) {
			d.logger.Warn("failed to resolve telemetry-relay service binding",
				"error", err,
			)
		}
		// Fall through to the "telemetry" binding.
		binding, err = messaging.GetState[schema.ServiceBindingContent](ctx, d.session, d.configRoomID, schema.EventTypeServiceBinding, telemetryServiceRole)
		if err != nil {
			if messaging.IsMatrixError(err, messaging.ErrCodeNotFound) {
				d.telemetrySocketPath = ""
				return ""
			}
			d.logger.Warn("failed to resolve telemetry service binding",
				"error", err,
			)
			d.telemetrySocketPath = ""
			return ""
		}
	}

	if binding.Principal.IsZero() {
		d.logger.Warn("telemetry service binding has empty principal")
		d.telemetrySocketPath = ""
		return ""
	}

	socketPath := binding.Principal.ServiceSocketPath(d.fleetRunDir)

	// Invite the telemetry principal to the config room so it can
	// observe principals on this machine. On a single-machine fleet
	// this is redundant (ensurePrincipalRoomAccess already invites
	// locally-deployed services), but on multi-machine fleets the
	// telemetry service runs on a different machine and wouldn't
	// otherwise be a member of this config room.
	d.ensurePrincipalRoomAccess(ctx, binding.Principal, d.configRoomID)

	d.logger.Info("resolved telemetry service binding",
		"principal", binding.Principal,
		"socket", socketPath,
	)
	d.telemetrySocketPath = socketPath
	return socketPath
}

// telemetryServiceRoles returns ["telemetry"] if a telemetry relay is
// deployed on this machine, or nil otherwise. Used when computing the
// full set of service roles that need token minting and refresh.
//
// Reads d.telemetrySocketPath which is set by resolveTelemetrySocket
// during each reconcile cycle.
func (d *Daemon) telemetryServiceRoles() []string {
	if d.telemetrySocketPath != "" {
		return []string{telemetryServiceRole}
	}
	return nil
}

// completeLogForPrincipal tells the telemetry service to flush remaining
// output and mark all log sessions for this principal as complete. Called
// on sandbox exit — the daemon doesn't know the session ID (generated by
// the launcher), so it sends source-only and the telemetry service
// completes all matching sessions.
//
// Best-effort: logs errors but never returns them. Missing output
// persistence is not worth blocking restart, drain cleanup, or exit
// notifications over. The stale reaper in the telemetry service acts
// as a fallback if this call fails.
//
// Must NOT be called while holding reconcileMu — the service client
// call blocks on network I/O.
func (d *Daemon) completeLogForPrincipal(ctx context.Context, principal ref.Entity) {
	if d.telemetrySocketPath == "" {
		return
	}

	token := &servicetoken.Token{
		Subject:   d.machine.UserID(),
		Machine:   d.machine,
		Audience:  telemetryServiceRole,
		Grants:    []servicetoken.Grant{{Actions: []string{"telemetry/ingest"}}},
		IssuedAt:  d.clock.Now().Unix(),
		ExpiresAt: d.clock.Now().Add(30 * time.Second).Unix(),
	}
	tokenBytes, err := servicetoken.Mint(d.tokenSigningPrivateKey, token)
	if err != nil {
		d.logger.Error("failed to mint complete-log token",
			"principal", principal,
			"error", err,
		)
		return
	}

	client := service.NewServiceClientFromToken(d.telemetrySocketPath, tokenBytes)

	request := telemetry.CompleteLogRequest{
		Source: principal.UserID(),
	}

	callContext, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	var response telemetry.CompleteLogResponse
	if err := client.Call(callContext, "complete-log", request, &response); err != nil {
		d.logger.Error("complete-log call failed",
			"principal", principal,
			"error", err,
		)
		return
	}

	d.logger.Info("telemetry log completed for principal",
		"principal", principal,
		"completed", response.Completed,
	)
}
