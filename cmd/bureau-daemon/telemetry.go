// Copyright 2026 The Bureau Authors
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"context"
	"encoding/json"
	"time"

	"github.com/bureau-foundation/bureau/lib/ref"
	"github.com/bureau-foundation/bureau/lib/schema"
	"github.com/bureau-foundation/bureau/lib/schema/telemetry"
	"github.com/bureau-foundation/bureau/lib/service"
	"github.com/bureau-foundation/bureau/lib/servicetoken"
	"github.com/bureau-foundation/bureau/messaging"
)

// telemetryServiceRole is the service role name for the per-machine
// telemetry relay. The daemon resolves this role from the config room's
// m.bureau.service_binding state to find the relay's socket path. The
// proxy uses a token with this audience to authenticate its telemetry
// submissions.
const telemetryServiceRole = "telemetry"

// resolveTelemetrySocket looks up the telemetry service binding in the
// machine's config room and returns the host-side socket path to the
// telemetry relay. Returns an empty string if no binding exists (telemetry
// relay not deployed) or if resolution fails (logged as a warning — not
// a fatal condition).
//
// Unlike resolveServiceSocket, this method treats all failures as
// non-fatal: telemetry is an optional enhancement, not a required
// dependency. Proxies start without telemetry when the relay is absent
// and log a diagnostic message at startup.
//
// Caches the result in d.telemetrySocketPath so the token refresh loop
// can include the telemetry role without re-resolving the binding.
// The caller must hold reconcileMu (which reconcile() always does).
func (d *Daemon) resolveTelemetrySocket(ctx context.Context) string {
	content, err := d.session.GetStateEvent(ctx, d.configRoomID, schema.EventTypeServiceBinding, telemetryServiceRole)
	if err != nil {
		if messaging.IsMatrixError(err, messaging.ErrCodeNotFound) {
			// No telemetry binding — relay not deployed on this machine.
			d.telemetrySocketPath = ""
			return ""
		}
		d.logger.Warn("failed to resolve telemetry service binding",
			"error", err,
		)
		d.telemetrySocketPath = ""
		return ""
	}

	var binding schema.ServiceBindingContent
	if err := json.Unmarshal(content, &binding); err != nil {
		d.logger.Warn("failed to parse telemetry service binding",
			"error", err,
		)
		d.telemetrySocketPath = ""
		return ""
	}

	if binding.Principal.IsZero() {
		d.logger.Warn("telemetry service binding has empty principal")
		d.telemetrySocketPath = ""
		return ""
	}

	socketPath := binding.Principal.ServiceSocketPath(d.fleetRunDir)
	d.logger.Info("resolved telemetry relay binding",
		"principal", binding.Principal,
		"socket", socketPath,
	)
	d.telemetrySocketPath = socketPath
	return socketPath
}

// telemetryServiceRoles returns ["telemetry"] if a telemetry relay is
// deployed on this machine, or nil otherwise. Used when computing the
// full set of service roles that need token minting and refresh.
//
// Reads d.telemetrySocketPath which is set by resolveTelemetrySocket
// during each reconcile cycle.
func (d *Daemon) telemetryServiceRoles() []string {
	if d.telemetrySocketPath != "" {
		return []string{telemetryServiceRole}
	}
	return nil
}

// completeLogForPrincipal tells the telemetry service to flush remaining
// output and mark all log sessions for this principal as complete. Called
// on sandbox exit — the daemon doesn't know the session ID (generated by
// the launcher), so it sends source-only and the telemetry service
// completes all matching sessions.
//
// Best-effort: logs errors but never returns them. Missing output
// persistence is not worth blocking restart, drain cleanup, or exit
// notifications over. The stale reaper in the telemetry service acts
// as a fallback if this call fails.
//
// Must NOT be called while holding reconcileMu — the service client
// call blocks on network I/O.
func (d *Daemon) completeLogForPrincipal(ctx context.Context, principal ref.Entity) {
	if d.telemetrySocketPath == "" {
		return
	}

	token := &servicetoken.Token{
		Subject:   d.machine.UserID(),
		Machine:   d.machine,
		Audience:  telemetryServiceRole,
		Grants:    []servicetoken.Grant{{Actions: []string{"telemetry/ingest"}}},
		IssuedAt:  d.clock.Now().Unix(),
		ExpiresAt: d.clock.Now().Add(30 * time.Second).Unix(),
	}
	tokenBytes, err := servicetoken.Mint(d.tokenSigningPrivateKey, token)
	if err != nil {
		d.logger.Error("failed to mint complete-log token",
			"principal", principal,
			"error", err,
		)
		return
	}

	client := service.NewServiceClientFromToken(d.telemetrySocketPath, tokenBytes)

	request := telemetry.CompleteLogRequest{
		Source: principal.AccountLocalpart(),
	}

	callContext, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	var response telemetry.CompleteLogResponse
	if err := client.Call(callContext, "complete-log", request, &response); err != nil {
		d.logger.Error("complete-log call failed",
			"principal", principal,
			"error", err,
		)
		return
	}

	d.logger.Info("telemetry log completed for principal",
		"principal", principal,
		"completed", response.Completed,
	)
}
