// Copyright 2026 The Bureau Authors
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"
)

// maxCapturedOutputLines is the maximum number of lines captured from a
// sandbox's tmux pane when the process exits with a non-zero exit code.
// This bounds the size of the output carried through IPC and into Matrix
// messages. The full scrollback (up to history-limit, currently 50000)
// exists in the pane until we kill the session, but only the tail is
// useful for diagnosing failures.
const maxCapturedOutputLines = 500

// paneDeadCaptureMaxAttempts is the maximum number of capture-pane attempts
// when waiting for tmux's "Pane is dead" line after detecting pane death.
//
// With the bureau-log-relay holding the outer PTY open, pane death and
// SIGCHLD are effectively simultaneous — the relay exits only after
// collecting the child's exit code via waitpid, so the "Pane is dead"
// line is almost always present on the first capture. The retries are a
// safety net for the brief window between the relay exiting (which
// triggers PTY EOF) and tmux processing the corresponding SIGCHLD.
const paneDeadCaptureMaxAttempts = 10

// paneDeadCaptureRetryDelay is the delay between capture-pane retries.
// 10 attempts x 50ms = 500ms maximum wait.
const paneDeadCaptureRetryDelay = 50 * time.Millisecond

// writeTmuxConfig writes a minimal tmux configuration file to the run
// directory and returns its path. The file is loaded when the tmux server
// first starts (via -f on new-session). Global options must be in this
// file rather than set via SetOption after session creation because a
// command that exits instantly can race with the option-setting code:
// the command exits, the session ends, the server exits (no remaining
// sessions), and the subsequent SetOption call fails with "no server
// running".
//
// Options set here:
//   - remain-on-exit: keeps the pane alive after the command exits so the
//     session watcher can capture terminal output via capture-pane.
//   - prefix: Ctrl-a (distinct from the user's Ctrl-b default).
//   - mouse: on for relay pass-through.
//   - history-limit: generous scrollback for observation history.
func writeTmuxConfig(runDir string) string {
	configPath := filepath.Join(runDir, "tmux.conf")
	config := "set-option -g remain-on-exit on\n" +
		"set-option -g prefix C-a\n" +
		"set-option -g mouse on\n" +
		"set-option -g history-limit 50000\n" +
		"set-option -g default-shell /bin/sh\n"
	if err := os.WriteFile(configPath, []byte(config), 0644); err != nil {
		// The run directory must be writable — if this fails, the
		// launcher is misconfigured. Panic is appropriate since we
		// haven't started serving yet.
		panic(fmt.Sprintf("writing tmux config to %s: %v", configPath, err))
	}
	return configPath
}

// tmuxSessionName returns the tmux session name for a principal.
// Bureau session names follow "bureau/<localpart>" — the slash in the
// localpart creates a natural hierarchy. Tmux treats "/" as a regular
// character in session names (only ":" and "." are delimiters in tmux
// target syntax).
func tmuxSessionName(localpart string) string {
	return "bureau/" + localpart
}

// createTmuxSession creates a detached tmux session for a principal on
// Bureau's dedicated tmux server. The session is configured with Bureau
// defaults: Ctrl-a prefix (distinct from the user's Ctrl-b), mouse support
// for relay pass-through, and generous scrollback for observation history.
//
// When command is provided, the tmux session runs that command instead of a
// bare shell. This is used for bwrap sandbox scripts — the command is the
// path to the script generated by buildSandboxCommand.
func (l *Launcher) createTmuxSession(localpart string, command ...string) error {
	sessionName := tmuxSessionName(localpart)

	// Ensure the tmux server socket directory exists.
	if err := os.MkdirAll(filepath.Dir(l.tmuxServer.SocketPath()), 0755); err != nil {
		return fmt.Errorf("creating tmux socket directory: %w", err)
	}

	// Create a detached tmux session. The first new-session on this socket
	// also starts the tmux server. When a command is provided, tmux runs
	// it instead of the default shell.
	//
	// The Server was created with configFile="/dev/null", which prevents
	// tmux from loading the user's ~/.tmux.conf. This avoids incompatible
	// options crashing the server. Bureau configures its own options via
	// configureTmuxSession after creation.
	if err := l.tmuxServer.NewSession(sessionName, command...); err != nil {
		return fmt.Errorf("creating tmux session %q: %w", sessionName, err)
	}

	l.configureTmuxSession(sessionName, localpart)

	l.logger.Info("tmux session created",
		"session", sessionName,
		"server_socket", l.tmuxServer.SocketPath(),
		"has_command", len(command) > 0,
	)
	return nil
}

// configureTmuxSession sets per-session tmux options (status bar content).
// Global options (prefix, mouse, history-limit, remain-on-exit) are loaded
// from the tmux config file written by writeTmuxConfig at server startup,
// which eliminates the race condition where a fast-exiting command causes
// the tmux server to exit before global SetOption calls execute.
func (l *Launcher) configureTmuxSession(sessionName, localpart string) {
	if err := l.tmuxServer.SetOption(sessionName, "status-left", fmt.Sprintf(" %s ", localpart)); err != nil {
		l.logger.Warn("setting tmux session status-left failed",
			"session", sessionName, "error", err)
	}
}

// destroyTmuxSession kills a principal's tmux session on Bureau's dedicated
// tmux server. Called during sandbox cleanup. Failures are logged as warnings
// because the session may already have been killed (the shell exited, or the
// session was never created due to an earlier failure).
func (l *Launcher) destroyTmuxSession(localpart string) {
	sessionName := tmuxSessionName(localpart)
	if err := l.tmuxServer.KillSession(sessionName); err != nil {
		l.logger.Debug("killing tmux session (may already be gone)",
			"session", sessionName, "error", err)
	} else {
		l.logger.Info("tmux session destroyed", "session", sessionName)
	}
}

// startSessionWatcher starts a background goroutine that monitors a sandbox's
// tmux session and drives its lifecycle to completion. This is the single
// lifecycle driver for all sandboxes — there are no special cases for pipeline
// executors vs interactive agents vs human operators.
//
// Two exit code detection strategies, used in priority order:
//
//  1. Exit code file (relay-backed sandboxes): bureau-log-relay writes the
//     child's exit code to a file (configDir/exit-code) after waitpid but
//     before os.Exit(). The watcher detects this via inotify on the
//     configDir, providing the authoritative exit code without any tmux
//     race conditions. This is the primary path for all sandboxes created
//     with a SandboxSpec.
//
//  2. Tmux polling (bare shells, reconnected sandboxes): polls PaneStatus
//     every 250ms. When the pane is dead, tries parsePaneDeadLine for the
//     exit code, falling back to #{pane_dead_status}. This path has a race
//     condition in tmux 3.4+ where #{pane_dead_status} can report 0 before
//     the real exit code is populated, but it's the only option when no
//     exit-code file exists.
//
// Both strategies also detect session disappearance (external kill by
// handleDestroySandbox, shutdownAllSandboxes, or tmux crash) and external
// finish (sb.done closed by another code path).
func (l *Launcher) startSessionWatcher(localpart string, sb *managedSandbox) {
	sessionName := tmuxSessionName(localpart)

	go func() {
		// Set up inotify watch for the exit-code file. For relay-backed
		// sandboxes, this is the primary detection path — it fires as
		// soon as the relay writes the file, with no polling latency.
		// For bare shells and reconnected sandboxes, exitCodeFilePath
		// is empty and exitCodeReady stays nil (never fires in select).
		var exitCodeReady <-chan struct{}
		var inotifyCleanup func()
		if sb.exitCodeFilePath != "" {
			directory := filepath.Dir(sb.exitCodeFilePath)
			filename := filepath.Base(sb.exitCodeFilePath)
			ready, cleanup, watchErr := watchForFile(directory, filename)
			if watchErr != nil {
				l.logger.Warn("inotify watch setup failed, using tmux polling only",
					"principal", localpart,
					"directory", directory,
					"error", watchErr,
				)
			} else {
				exitCodeReady = ready
				inotifyCleanup = cleanup
				defer cleanup()

				// Check if the relay already wrote the file before we
				// started watching. The watch is installed before this
				// check, so there's no race: if the file appeared
				// between watch setup and this stat, the inotify event
				// is already queued.
				if _, statErr := os.Stat(sb.exitCodeFilePath); statErr == nil {
					l.finishFromExitCodeFile(localpart, sessionName, sb)
					return
				}
			}
		}

		ticker := time.NewTicker(250 * time.Millisecond)
		defer ticker.Stop()

		for {
			select {
			case <-sb.done:
				// Sandbox already finished (e.g., handleDestroySandbox
				// called finishSandbox before we detected the exit).
				return
			case <-exitCodeReady:
				// Exit-code file appeared — authoritative exit code.
				// Clean up inotify before the potentially blocking
				// tmux capture calls.
				inotifyCleanup()
				l.finishFromExitCodeFile(localpart, sessionName, sb)
				return
			case <-ticker.C:
			}

			// Tmux polling: check pane death and session existence.
			dead, tmuxExitCode, statusErr := l.tmuxServer.PaneStatus(sessionName)
			if statusErr == nil && dead {
				l.finishFromPaneDeath(localpart, sessionName, sb, tmuxExitCode)
				return
			}

			// Session disappeared without pane death detection. This
			// happens when the session is killed externally
			// (handleDestroySandbox, shutdownAllSandboxes, tmux crash).
			if !l.tmuxServer.HasSession(sessionName) {
				l.logger.Info("tmux session disappeared",
					"principal", localpart,
					"session", sessionName,
				)
				l.finishSandbox(sb, -1, fmt.Errorf("tmux session disappeared"), "")
				return
			}
		}
	}()
}

// finishFromExitCodeFile reads the exit code from the file written by
// bureau-log-relay, captures pane output for non-zero exits, kills the
// tmux session, and finishes the sandbox. Called when inotify detects
// the exit-code file or when the file already exists at watch setup.
func (l *Launcher) finishFromExitCodeFile(localpart, sessionName string, sb *managedSandbox) {
	exitCode, err := readExitCodeFile(sb.exitCodeFilePath)
	if err != nil {
		// The file should be readable — inotify fired or stat succeeded.
		// If it's not, something unexpected happened. Fall back to tmux.
		l.logger.Warn("exit code file unreadable after detection",
			"principal", localpart,
			"path", sb.exitCodeFilePath,
			"error", err,
		)
		dead, tmuxCode, statusErr := l.tmuxServer.PaneStatus(sessionName)
		if statusErr == nil && dead {
			l.finishFromPaneDeath(localpart, sessionName, sb, tmuxCode)
			return
		}
		l.destroyTmuxSession(localpart)
		l.finishSandbox(sb, -1, fmt.Errorf("exit code file unreadable: %w", err), "")
		return
	}

	l.logger.Info("read exit code from file",
		"principal", localpart,
		"exit_code", exitCode,
		"path", sb.exitCodeFilePath,
	)

	// Capture pane output for non-zero exits. All child output is
	// already in the scrollback because child.Wait() completed before
	// the relay wrote the file. The pane may or may not be dead yet
	// (the relay hasn't necessarily exited), but capture works either
	// way — CapturePane reads scrollback from live or dead panes.
	var output string
	if exitCode != 0 {
		captured, captureErr := l.tmuxServer.CapturePane(sessionName, maxCapturedOutputLines)
		if captureErr != nil {
			l.logger.Warn("failed to capture pane output",
				"principal", localpart,
				"session", sessionName,
				"error", captureErr,
			)
		} else {
			output = strings.TrimRight(captured, "\n")
		}
	}

	l.destroyTmuxSession(localpart)

	var exitError error
	if exitCode != 0 {
		exitError = fmt.Errorf("sandbox command exited with code %d", exitCode)
	}

	l.logger.Info("sandbox process exited",
		"principal", localpart,
		"session", sessionName,
		"exit_code", exitCode,
		"exit_code_source", "file",
		"captured_output_length", len(output),
	)

	l.finishSandbox(sb, exitCode, exitError, output)
}

// finishFromPaneDeath handles exit detection via tmux polling. This is the
// fallback path for bare-shell sessions (no SandboxSpec, no relay, no
// exit-code file), reconnected sandboxes after launcher exec(), and
// relay-backed sandboxes where the relay was killed by a signal before
// writing the exit-code file.
//
// Exit code priority: exit-code file (if it exists) > parsePaneDeadLine >
// tmux #{pane_dead_status} format variable. The file check handles
// reconnected sandboxes where the relay wrote the file before the launcher
// restarted. The "Pane is dead" line is more reliable than the format
// variable, which has a race condition in tmux 3.4+ that can report stale
// values under load.
func (l *Launcher) finishFromPaneDeath(localpart, sessionName string, sb *managedSandbox, tmuxExitCode int) {
	l.logger.Info("pane dead detected",
		"principal", localpart,
		"session", sessionName,
		"exit_code_from_format_var", tmuxExitCode,
	)

	exitCode := tmuxExitCode
	exitCodeSource := "tmux_format_var"

	// Prefer the exit-code file if it exists. This catches reconnected
	// sandboxes (relay wrote the file before launcher exec'd) and the
	// case where inotify wasn't set up but the relay still wrote the file.
	if sb.exitCodeFilePath != "" {
		if fileCode, err := readExitCodeFile(sb.exitCodeFilePath); err == nil {
			exitCode = fileCode
			exitCodeSource = "file"
			l.logger.Info("exit code from file overrides tmux format variable",
				"principal", localpart,
				"file_exit_code", fileCode,
				"tmux_exit_code", tmuxExitCode,
			)
		}
	}

	// Capture pane content. For the tmux polling path without an
	// exit-code file, also try parsing the "Pane is dead" line for a
	// more reliable exit code than the format variable.
	var output string
	captured, captureErr := l.tmuxServer.CapturePane(sessionName, maxCapturedOutputLines)
	if captureErr != nil {
		l.logger.Warn("failed to capture pane output",
			"principal", localpart,
			"session", sessionName,
			"error", captureErr,
		)
	} else {
		output = strings.TrimRight(captured, "\n")

		// If we're still relying on the tmux format variable (no file),
		// try the "Pane is dead" line. This is more reliable because tmux
		// only renders the line after fully processing SIGCHLD, while the
		// format variable can be stale in tmux 3.4+.
		if exitCodeSource == "tmux_format_var" {
			if parsedCode, ok := parsePaneDeadLine(output); ok {
				exitCode = parsedCode
				exitCodeSource = "pane_dead_line"
			} else {
				for attempt := 1; attempt < paneDeadCaptureMaxAttempts; attempt++ {
					time.Sleep(paneDeadCaptureRetryDelay)
					recaptured, recaptureErr := l.tmuxServer.CapturePane(sessionName, maxCapturedOutputLines)
					if recaptureErr != nil {
						break
					}
					output = strings.TrimRight(recaptured, "\n")
					if parsedCode, ok := parsePaneDeadLine(output); ok {
						exitCode = parsedCode
						exitCodeSource = "pane_dead_line"
						break
					}
				}
				if exitCodeSource == "tmux_format_var" {
					l.logger.Warn("pane dead line not found; using format variable exit code",
						"principal", localpart,
						"session", sessionName,
						"exit_code", exitCode,
						"attempts", paneDeadCaptureMaxAttempts,
					)
				}
			}
		}
	}

	l.destroyTmuxSession(localpart)

	var exitError error
	if exitCode != 0 {
		exitError = fmt.Errorf("sandbox command exited with code %d", exitCode)
	}

	// Clear output for successful exits — no diagnostics needed.
	if exitCode == 0 {
		output = ""
	}

	l.logger.Info("sandbox process exited",
		"principal", localpart,
		"session", sessionName,
		"exit_code", exitCode,
		"exit_code_source", exitCodeSource,
		"captured_output_length", len(output),
	)

	l.finishSandbox(sb, exitCode, exitError, output)
}

// readExitCodeFile reads and parses the exit code from a file written
// by bureau-log-relay. The file contains a single integer in ASCII
// decimal followed by a newline (e.g., "42\n").
func readExitCodeFile(path string) (int, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return 0, err
	}
	code, err := strconv.Atoi(strings.TrimSpace(string(data)))
	if err != nil {
		return 0, fmt.Errorf("parsing exit code from %q: %w", string(data), err)
	}
	return code, nil
}

// paneDeadStatusRegexp matches tmux's "Pane is dead (status N, ...)" line.
// tmux appends this line to the pane content when remain-on-exit is enabled
// and the pane command exits normally. The captured group is the exit code.
var paneDeadStatusRegexp = regexp.MustCompile(`Pane is dead \(status (\d+),`)

// paneDeadSignalRegexp matches tmux's "Pane is dead (signal N, ...)" line.
// tmux appends this line when the pane command is killed by a signal. The
// captured group is the signal number; the exit code follows the shell
// convention (128 + signal).
var paneDeadSignalRegexp = regexp.MustCompile(`Pane is dead \(signal (\d+),`)

// parsePaneDeadLine extracts the exit code from tmux's "Pane is dead" status
// line in captured pane output. With remain-on-exit enabled, tmux always
// appends this line when a pane command exits, making it a reliable source
// of exit code information — more reliable than #{pane_dead_status} format
// variables, which have a race window in tmux 3.4+.
//
// Returns the exit code and true if parsed, or 0 and false if the line
// wasn't found.
func parsePaneDeadLine(capturedOutput string) (int, bool) {
	// Check for signal death first (takes precedence).
	if match := paneDeadSignalRegexp.FindStringSubmatch(capturedOutput); match != nil {
		signalNumber, err := strconv.Atoi(match[1])
		if err == nil {
			return 128 + signalNumber, true
		}
	}

	// Check for normal exit.
	if match := paneDeadStatusRegexp.FindStringSubmatch(capturedOutput); match != nil {
		exitCode, err := strconv.Atoi(match[1])
		if err == nil {
			return exitCode, true
		}
	}

	return 0, false
}
