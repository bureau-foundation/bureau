// Copyright 2026 The Bureau Authors
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

// maxCapturedOutputLines is the maximum number of lines captured from a
// sandbox's tmux pane when the process exits with a non-zero exit code.
// This bounds the size of the output carried through IPC and into Matrix
// messages. The full scrollback (up to history-limit, currently 50000)
// exists in the pane until we kill the session, but only the tail is
// useful for diagnosing failures.
const maxCapturedOutputLines = 500

// writeTmuxConfig writes a minimal tmux configuration file to the run
// directory and returns its path. The file is loaded when the tmux server
// first starts (via -f on new-session). Global options must be in this
// file rather than set via SetOption after session creation because a
// command that exits instantly can race with the option-setting code:
// the command exits, the session ends, the server exits (no remaining
// sessions), and the subsequent SetOption call fails with "no server
// running".
//
// Options set here:
//   - remain-on-exit: keeps the pane alive after the command exits so the
//     session watcher can capture terminal output via capture-pane.
//   - prefix: Ctrl-a (distinct from the user's Ctrl-b default).
//   - mouse: on for relay pass-through.
//   - history-limit: generous scrollback for observation history.
func writeTmuxConfig(runDir string) string {
	configPath := filepath.Join(runDir, "tmux.conf")
	config := "set-option -g remain-on-exit on\n" +
		"set-option -g prefix C-a\n" +
		"set-option -g mouse on\n" +
		"set-option -g history-limit 50000\n"
	if err := os.WriteFile(configPath, []byte(config), 0644); err != nil {
		// The run directory must be writable — if this fails, the
		// launcher is misconfigured. Panic is appropriate since we
		// haven't started serving yet.
		panic(fmt.Sprintf("writing tmux config to %s: %v", configPath, err))
	}
	return configPath
}

// tmuxSessionName returns the tmux session name for a principal.
// Bureau session names follow "bureau/<localpart>" — the slash in the
// localpart creates a natural hierarchy. Tmux treats "/" as a regular
// character in session names (only ":" and "." are delimiters in tmux
// target syntax).
func tmuxSessionName(localpart string) string {
	return "bureau/" + localpart
}

// createTmuxSession creates a detached tmux session for a principal on
// Bureau's dedicated tmux server. The session is configured with Bureau
// defaults: Ctrl-a prefix (distinct from the user's Ctrl-b), mouse support
// for relay pass-through, and generous scrollback for observation history.
//
// When command is provided, the tmux session runs that command instead of a
// bare shell. This is used for bwrap sandbox scripts — the command is the
// path to the script generated by buildSandboxCommand.
func (l *Launcher) createTmuxSession(localpart string, command ...string) error {
	sessionName := tmuxSessionName(localpart)

	// Ensure the tmux server socket directory exists.
	if err := os.MkdirAll(filepath.Dir(l.tmuxServer.SocketPath()), 0755); err != nil {
		return fmt.Errorf("creating tmux socket directory: %w", err)
	}

	// Create a detached tmux session. The first new-session on this socket
	// also starts the tmux server. When a command is provided, tmux runs
	// it instead of the default shell.
	//
	// The Server was created with configFile="/dev/null", which prevents
	// tmux from loading the user's ~/.tmux.conf. This avoids incompatible
	// options crashing the server. Bureau configures its own options via
	// configureTmuxSession after creation.
	if err := l.tmuxServer.NewSession(sessionName, command...); err != nil {
		return fmt.Errorf("creating tmux session %q: %w", sessionName, err)
	}

	l.configureTmuxSession(sessionName, localpart)

	l.logger.Info("tmux session created",
		"session", sessionName,
		"server_socket", l.tmuxServer.SocketPath(),
		"has_command", len(command) > 0,
	)
	return nil
}

// configureTmuxSession sets per-session tmux options (status bar content).
// Global options (prefix, mouse, history-limit, remain-on-exit) are loaded
// from the tmux config file written by writeTmuxConfig at server startup,
// which eliminates the race condition where a fast-exiting command causes
// the tmux server to exit before global SetOption calls execute.
func (l *Launcher) configureTmuxSession(sessionName, localpart string) {
	if err := l.tmuxServer.SetOption(sessionName, "status-left", fmt.Sprintf(" %s ", localpart)); err != nil {
		l.logger.Warn("setting tmux session status-left failed",
			"session", sessionName, "error", err)
	}
}

// destroyTmuxSession kills a principal's tmux session on Bureau's dedicated
// tmux server. Called during sandbox cleanup. Failures are logged as warnings
// because the session may already have been killed (the shell exited, or the
// session was never created due to an earlier failure).
func (l *Launcher) destroyTmuxSession(localpart string) {
	sessionName := tmuxSessionName(localpart)
	if err := l.tmuxServer.KillSession(sessionName); err != nil {
		l.logger.Debug("killing tmux session (may already be gone)",
			"session", sessionName, "error", err)
	} else {
		l.logger.Info("tmux session destroyed", "session", sessionName)
	}
}

// startSessionWatcher starts a background goroutine that monitors a sandbox's
// tmux session and drives its lifecycle to completion. This is the single
// lifecycle driver for all sandboxes — there are no special cases for pipeline
// executors vs interactive agents vs human operators.
//
// Detection strategy: the tmux session has remain-on-exit enabled, so when the
// sandboxed process exits, the pane stays alive (showing "Pane is dead") instead
// of being destroyed. The watcher polls for two conditions:
//
//  1. Exit code file exists — the sandbox script wrote it just before exiting.
//     The pane is still alive (remain-on-exit), so we can capture its scrollback
//     via capture-pane, then kill the session.
//
//  2. Session gone — something external killed the session (handleDestroySandbox,
//     shutdownAllSandboxes, or tmux server crash). No pane capture is possible.
//     This is the fallback; the primary detection is (1).
//
// The watcher also listens on sb.done for early termination by other code paths
// (e.g., handleDestroySandbox calls finishSandbox directly to avoid waiting for
// the next poll interval).
func (l *Launcher) startSessionWatcher(localpart string, sb *managedSandbox) {
	sessionName := tmuxSessionName(localpart)
	exitCodePath := filepath.Join(sb.configDir, "exit-code")

	go func() {
		ticker := time.NewTicker(250 * time.Millisecond)
		defer ticker.Stop()

		for {
			select {
			case <-sb.done:
				// Sandbox already finished (e.g., handleDestroySandbox
				// called finishSandbox before we detected the exit).
				return
			case <-ticker.C:
			}

			// Primary detection: check if the exit code file exists. The
			// sandbox script writes this just before exiting, and
			// remain-on-exit keeps the tmux pane alive so we can still
			// capture its content.
			if _, statErr := os.Stat(exitCodePath); statErr == nil {
				exitCode := -1
				if data, readErr := os.ReadFile(exitCodePath); readErr == nil {
					if code, parseErr := strconv.Atoi(strings.TrimSpace(string(data))); parseErr == nil {
						exitCode = code
					}
				}

				// Capture the pane content before killing the session.
				// On failure (e.g., tmux server crashed between the stat
				// and capture), proceed without output — the exit code
				// alone is still valuable.
				var output string
				if exitCode != 0 {
					captured, captureErr := l.tmuxServer.CapturePane(sessionName, maxCapturedOutputLines)
					if captureErr != nil {
						l.logger.Warn("failed to capture pane output",
							"principal", localpart,
							"session", sessionName,
							"error", captureErr,
						)
					} else {
						output = strings.TrimRight(captured, "\n")
					}
				}

				// Kill the session now that we have the output. The pane
				// was kept alive by remain-on-exit solely for this capture.
				l.destroyTmuxSession(localpart)

				var exitError error
				if exitCode != 0 {
					exitError = fmt.Errorf("sandbox command exited with code %d", exitCode)
				}

				l.logger.Info("sandbox process exited",
					"principal", localpart,
					"session", sessionName,
					"exit_code", exitCode,
					"captured_output_length", len(output),
				)

				l.finishSandbox(sb, exitCode, exitError, output)
				return
			}

			// Fallback: session disappeared without writing an exit code
			// file. This happens when the session is killed externally
			// (handleDestroySandbox, shutdownAllSandboxes, tmux crash).
			// No output capture is possible — the pane is already gone.
			if !l.tmuxServer.HasSession(sessionName) {
				exitCode := -1
				if data, readErr := os.ReadFile(exitCodePath); readErr == nil {
					if code, parseErr := strconv.Atoi(strings.TrimSpace(string(data))); parseErr == nil {
						exitCode = code
					}
				}
				var exitError error
				if exitCode != 0 {
					exitError = fmt.Errorf("sandbox command exited with code %d", exitCode)
				}

				l.logger.Info("tmux session disappeared",
					"principal", localpart,
					"session", sessionName,
					"exit_code", exitCode,
				)

				l.finishSandbox(sb, exitCode, exitError, "")
				return
			}
		}
	}()
}
