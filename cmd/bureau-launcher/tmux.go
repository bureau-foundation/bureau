// Copyright 2026 The Bureau Authors
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"
)

// maxCapturedOutputLines is the maximum number of lines captured from a
// sandbox's tmux pane when the process exits with a non-zero exit code.
// This bounds the size of the output carried through IPC and into Matrix
// messages. The full scrollback (up to history-limit, currently 50000)
// exists in the pane until we kill the session, but only the tail is
// useful for diagnosing failures.
const maxCapturedOutputLines = 500

// paneDeadCaptureMaxAttempts is the maximum number of capture-pane attempts
// when waiting for tmux's "Pane is dead" line after detecting pane death.
//
// With the bureau-log-relay holding the outer PTY open, pane death and
// SIGCHLD are effectively simultaneous — the relay exits only after
// collecting the child's exit code via waitpid, so the "Pane is dead"
// line is almost always present on the first capture. The retries are a
// safety net for the brief window between the relay exiting (which
// triggers PTY EOF) and tmux processing the corresponding SIGCHLD.
const paneDeadCaptureMaxAttempts = 10

// paneDeadCaptureRetryDelay is the delay between capture-pane retries.
// 10 attempts x 50ms = 500ms maximum wait.
const paneDeadCaptureRetryDelay = 50 * time.Millisecond

// writeTmuxConfig writes a minimal tmux configuration file to the run
// directory and returns its path. The file is loaded when the tmux server
// first starts (via -f on new-session). Global options must be in this
// file rather than set via SetOption after session creation because a
// command that exits instantly can race with the option-setting code:
// the command exits, the session ends, the server exits (no remaining
// sessions), and the subsequent SetOption call fails with "no server
// running".
//
// Options set here:
//   - remain-on-exit: keeps the pane alive after the command exits so the
//     session watcher can capture terminal output via capture-pane.
//   - prefix: Ctrl-a (distinct from the user's Ctrl-b default).
//   - mouse: on for relay pass-through.
//   - history-limit: generous scrollback for observation history.
func writeTmuxConfig(runDir string) string {
	configPath := filepath.Join(runDir, "tmux.conf")
	config := "set-option -g remain-on-exit on\n" +
		"set-option -g prefix C-a\n" +
		"set-option -g mouse on\n" +
		"set-option -g history-limit 50000\n"
	if err := os.WriteFile(configPath, []byte(config), 0644); err != nil {
		// The run directory must be writable — if this fails, the
		// launcher is misconfigured. Panic is appropriate since we
		// haven't started serving yet.
		panic(fmt.Sprintf("writing tmux config to %s: %v", configPath, err))
	}
	return configPath
}

// tmuxSessionName returns the tmux session name for a principal.
// Bureau session names follow "bureau/<localpart>" — the slash in the
// localpart creates a natural hierarchy. Tmux treats "/" as a regular
// character in session names (only ":" and "." are delimiters in tmux
// target syntax).
func tmuxSessionName(localpart string) string {
	return "bureau/" + localpart
}

// createTmuxSession creates a detached tmux session for a principal on
// Bureau's dedicated tmux server. The session is configured with Bureau
// defaults: Ctrl-a prefix (distinct from the user's Ctrl-b), mouse support
// for relay pass-through, and generous scrollback for observation history.
//
// When command is provided, the tmux session runs that command instead of a
// bare shell. This is used for bwrap sandbox scripts — the command is the
// path to the script generated by buildSandboxCommand.
func (l *Launcher) createTmuxSession(localpart string, command ...string) error {
	sessionName := tmuxSessionName(localpart)

	// Ensure the tmux server socket directory exists.
	if err := os.MkdirAll(filepath.Dir(l.tmuxServer.SocketPath()), 0755); err != nil {
		return fmt.Errorf("creating tmux socket directory: %w", err)
	}

	// Create a detached tmux session. The first new-session on this socket
	// also starts the tmux server. When a command is provided, tmux runs
	// it instead of the default shell.
	//
	// The Server was created with configFile="/dev/null", which prevents
	// tmux from loading the user's ~/.tmux.conf. This avoids incompatible
	// options crashing the server. Bureau configures its own options via
	// configureTmuxSession after creation.
	if err := l.tmuxServer.NewSession(sessionName, command...); err != nil {
		return fmt.Errorf("creating tmux session %q: %w", sessionName, err)
	}

	l.configureTmuxSession(sessionName, localpart)

	l.logger.Info("tmux session created",
		"session", sessionName,
		"server_socket", l.tmuxServer.SocketPath(),
		"has_command", len(command) > 0,
	)
	return nil
}

// configureTmuxSession sets per-session tmux options (status bar content).
// Global options (prefix, mouse, history-limit, remain-on-exit) are loaded
// from the tmux config file written by writeTmuxConfig at server startup,
// which eliminates the race condition where a fast-exiting command causes
// the tmux server to exit before global SetOption calls execute.
func (l *Launcher) configureTmuxSession(sessionName, localpart string) {
	if err := l.tmuxServer.SetOption(sessionName, "status-left", fmt.Sprintf(" %s ", localpart)); err != nil {
		l.logger.Warn("setting tmux session status-left failed",
			"session", sessionName, "error", err)
	}
}

// destroyTmuxSession kills a principal's tmux session on Bureau's dedicated
// tmux server. Called during sandbox cleanup. Failures are logged as warnings
// because the session may already have been killed (the shell exited, or the
// session was never created due to an earlier failure).
func (l *Launcher) destroyTmuxSession(localpart string) {
	sessionName := tmuxSessionName(localpart)
	if err := l.tmuxServer.KillSession(sessionName); err != nil {
		l.logger.Debug("killing tmux session (may already be gone)",
			"session", sessionName, "error", err)
	} else {
		l.logger.Info("tmux session destroyed", "session", sessionName)
	}
}

// startSessionWatcher starts a background goroutine that monitors a sandbox's
// tmux session and drives its lifecycle to completion. This is the single
// lifecycle driver for all sandboxes — there are no special cases for pipeline
// executors vs interactive agents vs human operators.
//
// Detection strategy: the tmux session has remain-on-exit enabled, so when the
// sandboxed process exits, the pane stays alive (showing "Pane is dead") instead
// of being destroyed. The watcher polls PaneStatus (#{pane_dead},
// #{pane_dead_status}, #{pane_dead_signal}) to detect process exit.
//
// Exit code reliability: the bureau-log-relay wraps the sandbox script,
// holding the outer PTY open until it has collected the child's exit code
// via waitpid. This makes PTY EOF and SIGCHLD effectively simultaneous
// from tmux's perspective, so #{pane_dead_status} and the "Pane is dead"
// line are both available immediately when the watcher detects pane death.
// A small capture-retry loop handles the rare case where tmux's event loop
// hasn't quite finished SIGCHLD processing on the first poll.
//
// Two detection paths:
//
//  1. PaneStatus reports dead — the log relay exited and remain-on-exit kept
//     the pane alive. The watcher captures scrollback (for non-zero exits),
//     kills the session, and reports the exit code.
//
//  2. Session gone — something external killed the session (handleDestroySandbox,
//     shutdownAllSandboxes, or tmux server crash). No pane capture is possible.
//
// The watcher also listens on sb.done for early termination by other code paths
// (e.g., handleDestroySandbox calls finishSandbox directly to avoid waiting for
// the next poll interval).
func (l *Launcher) startSessionWatcher(localpart string, sb *managedSandbox) {
	sessionName := tmuxSessionName(localpart)

	go func() {
		ticker := time.NewTicker(250 * time.Millisecond)
		defer ticker.Stop()

		for {
			select {
			case <-sb.done:
				// Sandbox already finished (e.g., handleDestroySandbox
				// called finishSandbox before we detected the exit).
				return
			case <-ticker.C:
			}

			// Primary detection: check if the pane process has exited.
			// PaneStatus queries tmux's #{pane_dead}, #{pane_dead_status},
			// and #{pane_dead_signal} format variables. For signal deaths,
			// the exit code follows the shell convention (128 + signal).
			dead, exitCode, statusErr := l.tmuxServer.PaneStatus(sessionName)
			if statusErr == nil && dead {
				l.logger.Info("pane dead detected",
					"principal", localpart,
					"session", sessionName,
					"exit_code_from_format_var", exitCode,
				)

				// Capture pane content and extract the authoritative exit
				// code from tmux's "Pane is dead (status N, ...)" line.
				// With the log relay holding the outer PTY, the line is
				// almost always present on the first capture. The retry
				// loop handles the brief window between PTY EOF and
				// SIGCHLD processing in tmux's event loop.
				var output string
				for attempt := 0; attempt < paneDeadCaptureMaxAttempts; attempt++ {
					if attempt > 0 {
						time.Sleep(paneDeadCaptureRetryDelay)
					}

					captured, captureErr := l.tmuxServer.CapturePane(sessionName, maxCapturedOutputLines)
					if captureErr != nil {
						l.logger.Warn("failed to capture pane output",
							"principal", localpart,
							"session", sessionName,
							"attempt", attempt,
							"error", captureErr,
						)
						break
					}

					output = strings.TrimRight(captured, "\n")
					if parsedCode, ok := parsePaneDeadLine(output); ok {
						exitCode = parsedCode
						break
					}

					if attempt == paneDeadCaptureMaxAttempts-1 {
						l.logger.Warn("pane dead line not found after retries; using format variable exit code",
							"principal", localpart,
							"session", sessionName,
							"exit_code_from_format_var", exitCode,
							"attempts", paneDeadCaptureMaxAttempts,
							"captured_output_length", len(output),
						)
					}
				}

				// Kill the session now that we have the output. The pane
				// was kept alive by remain-on-exit solely for this capture.
				l.destroyTmuxSession(localpart)

				var exitError error
				if exitCode != 0 {
					exitError = fmt.Errorf("sandbox command exited with code %d", exitCode)
				}

				// Only include captured output in the finish message for
				// non-zero exits. Successful exits don't need diagnostics.
				if exitCode == 0 {
					output = ""
				}

				l.logger.Info("sandbox process exited",
					"principal", localpart,
					"session", sessionName,
					"exit_code", exitCode,
					"captured_output_length", len(output),
				)

				l.finishSandbox(sb, exitCode, exitError, output)
				return
			}

			// Fallback: session disappeared without PaneStatus detecting
			// the exit first. This happens when the session is killed
			// externally (handleDestroySandbox, shutdownAllSandboxes,
			// tmux crash). No output capture is possible.
			if !l.tmuxServer.HasSession(sessionName) {
				l.logger.Info("tmux session disappeared",
					"principal", localpart,
					"session", sessionName,
				)

				l.finishSandbox(sb, -1, fmt.Errorf("tmux session disappeared"), "")
				return
			}
		}
	}()
}

// paneDeadStatusRegexp matches tmux's "Pane is dead (status N, ...)" line.
// tmux appends this line to the pane content when remain-on-exit is enabled
// and the pane command exits normally. The captured group is the exit code.
var paneDeadStatusRegexp = regexp.MustCompile(`Pane is dead \(status (\d+),`)

// paneDeadSignalRegexp matches tmux's "Pane is dead (signal N, ...)" line.
// tmux appends this line when the pane command is killed by a signal. The
// captured group is the signal number; the exit code follows the shell
// convention (128 + signal).
var paneDeadSignalRegexp = regexp.MustCompile(`Pane is dead \(signal (\d+),`)

// parsePaneDeadLine extracts the exit code from tmux's "Pane is dead" status
// line in captured pane output. With remain-on-exit enabled, tmux always
// appends this line when a pane command exits, making it a reliable source
// of exit code information — more reliable than #{pane_dead_status} format
// variables, which have a race window in tmux 3.4+.
//
// Returns the exit code and true if parsed, or 0 and false if the line
// wasn't found.
func parsePaneDeadLine(capturedOutput string) (int, bool) {
	// Check for signal death first (takes precedence).
	if match := paneDeadSignalRegexp.FindStringSubmatch(capturedOutput); match != nil {
		signalNumber, err := strconv.Atoi(match[1])
		if err == nil {
			return 128 + signalNumber, true
		}
	}

	// Check for normal exit.
	if match := paneDeadStatusRegexp.FindStringSubmatch(capturedOutput); match != nil {
		exitCode, err := strconv.Atoi(match[1])
		if err == nil {
			return exitCode, true
		}
	}

	return 0, false
}
