# Agent Context

[agent-layering.md](agent-layering.md) describes how agents are wrapped,
executed, and observed. [tickets.md](tickets.md) describes work items,
dependencies, and coordination. This document describes agent context:
the system for capturing, storing, forking, and resuming an agent's
accumulated understanding across sandbox lifecycles, machines, and time.

---

## Why Context

When an agent works on a problem, it builds understanding: which files
matter, what the code does, where the bug is, why the previous approach
didn't work. Today this understanding exists only in the LLM's context
window for the duration of a single sandbox lifecycle. When the sandbox
exits — task complete, crash, preemption, compaction — the understanding
is gone.

This creates three problems:

- **No resumption.** An agent that exits mid-task starts from scratch
  next time. It re-reads the same files, re-discovers the same
  constraints, re-makes the same decisions. This wastes tokens, time,
  and money.

- **No collaboration.** When a reviewer finds a bug and the author wants
  to ask "what do you mean?", the reviewer's understanding doesn't exist
  anymore. The author gets a cold finding ticket with a description, not
  a conversation partner who remembers the code, the intent, and the
  tradeoffs they considered.

- **No accountability.** After the fact, "why did the agent do this?"
  has no answer. The reasoning that led to a decision evaporated with
  the sandbox.

Agent context solves these by making an agent's understanding a
first-class, storable, resumable, forkable artifact.

---

## Core Concepts

### Context Commits

A context commit is a snapshot of an agent's understanding at a specific
point in time. It is the fundamental unit of the context system.

Each context commit contains:

- **A delta** — the new conversation entries (messages, tool calls, tool
  results) since the parent commit. Not a full snapshot; just what's new.

- **A parent** — the previous context commit in the chain. Null for the
  root of a new conversation.

- **Provenance** — which agent template produced this, which principal
  executed it, on which machine, in which session. The template is
  structural (what kind of agent); the principal and machine are
  informative (where it happened to run).

- **A summary** — a human-readable description of the agent's
  understanding at this point. Always present, always readable regardless
  of format version. Can be generated at commit time or added later by a
  batch summarization service.

Context commits are stored as artifacts in the CAS (content-addressed
storage). Each commit's delta is an artifact; the commit metadata
(parent, provenance, summary) lives in the agent service.

### The `ctx-*` ID Scheme

Context commits are identified by `ctx-` prefixed short IDs, following
the same pattern as `tkt-` (tickets) and `art-` (artifacts). A ctx-*
ID is the logical handle for a context commit. It resolves to commit
metadata in the agent service, which includes the artifact ref for the
delta content.

The ID is generated by the agent service from deterministic inputs
(parent ref, artifact ref, timestamp, template). It is unambiguous —
`ctx-` does not collide with `tkt-`, `art-`, or Matrix identifiers.

### Chains

Context commits form chains through parent links, analogous to git
commits. A chain represents the evolution of an agent's understanding
over the course of a task:

```
ctx-a001 (root: messages 1-5)
  └→ ctx-a002 (delta: messages 6-10)
       └→ ctx-a003 (delta: messages 11-15)
            └→ ctx-a004 (delta: messages 16-20)
```

Each commit stores only the delta. The full conversation at any point
is the concatenation of all deltas from root to that commit. This gives
storage proportional to the total conversation size, not proportional
to the number of checkpoints times the conversation size.

### Branching and Forking

Two context commits can share the same parent. This happens naturally
when an agent's understanding at one point leads to multiple independent
conversations:

```
ctx-a003 (reviewer's understanding after examining code)
  ├→ ctx-b001 (discussion thread about finding #1)
  │    └→ ctx-b002 (continued discussion)
  └→ ctx-c001 (discussion thread about finding #2)
       └→ ctx-c002 (continued discussion)
```

Each branch is an independent conversation that diverges from a shared
starting point. The reviewer in the finding #1 discussion never sees
messages from the finding #2 discussion, and vice versa — they are
separate agent instances with separate chains.

Branching is not a special operation. It is the natural result of two
context commits naming the same parent. The agent service does not
enforce or prevent it.

### Compaction Commits

LLM context windows are finite, and model performance degrades as
context grows. Agents compact their context — summarizing older
conversation to make room for new work. The context chain captures
compaction as a special commit type:

```
ctx-a001 (delta: messages 1-10)
  └→ ctx-a002 (delta: messages 11-20)
       └→ ctx-a003 (delta: messages 21-30)
            └→ ctx-a004 (COMPACTION: summary of messages 1-30)
                 └→ ctx-a005 (delta: messages 31-35, post-compaction)
```

A compaction commit's artifact is the summary that replaces the prefix,
not a delta of new messages. It acts as a reset point in the chain:
default materialization stops at the nearest compaction and uses the
summary as the conversation prefix. The full pre-compaction history
remains reachable by walking past the compaction node.

Compaction commits are created when:

- The LLM runtime compacts (Anthropic's server-side compaction, Claude
  Code's `/compact`, the native agent's context manager dropping turn
  groups).

- An operator or batch service explicitly compacts an old chain
  (re-summarizing with a newer model for better fidelity).

The pre-compaction delta is always checkpointed before the compaction
commit, so the full conversation is preserved in the chain even though
the live agent only sees the summary going forward.

---

## Data Model

### Context Commit Metadata

The agent service stores metadata for each context commit:

- **ID** — `ctx-*` identifier.
- **Parent** — parent commit ID. Empty for root commits.
- **CommitType** — `delta`, `compaction`, or `snapshot`.
  - `delta`: the artifact contains new conversation entries since the
    parent.
  - `compaction`: the artifact contains a summary replacing the prefix
    chain. Materialization stops here by default.
  - `snapshot`: a full materialized context stored as a single artifact,
    used for caching or for contexts imported from external systems.
- **ArtifactRef** — BLAKE3 ref pointing to the delta (or compaction
  summary, or full snapshot) in the CAS.
- **Format** — the serialization format of the delta. Determines how
  deltas are concatenated during materialization and how translation
  works.
- **Template** — the agent template that produced this commit. Structural
  identity: what kind of agent this is.
- **Principal** — the principal that executed this commit. Informative:
  where it ran.
- **Machine** — the machine the principal ran on. Informative.
- **SessionID** — the session within which this commit was created.
- **Checkpoint** — what triggered this commit: `turn_boundary`,
  `tool_call`, `compaction`, `session_end`, `explicit`.
- **TicketID** — the ticket being worked, if applicable.
- **ThreadID** — the Matrix thread, if this commit is part of a thread
  conversation.
- **Summary** — human-readable description of the agent's understanding.
  Mutable (can be added or updated after creation). The artifact is
  immutable; the summary is metadata.
- **MessageCount** — number of messages in this delta.
- **TokenCount** — approximate token count of this delta.
- **CreatedAt** — ISO 8601 timestamp.

### Delta Formats

The delta artifact format is agent-runtime-specific. The `format` field
on the commit tells the agent service how to concatenate deltas during
materialization:

- **`events-v1`** — CBOR-encoded `[]agentdriver.Event` arrays. Each
  delta is a CBOR array of structured `Event` structs with typed
  payloads (prompt, response, thinking, tool call, tool result, system,
  metric, error, output). Concatenation decodes both arrays and merges
  them. This is the primary checkpoint format for all agent runtimes:
  both the Claude Code wrapper and the native agent produce
  `agentdriver.Event` streams, and the checkpoint tracker serializes
  them identically. The event types are runtime-agnostic — the same
  `ToolCallEvent` represents a tool invocation whether it came from
  Claude Code's stream-json or the native agent's Go structs.

- **`claude-code-v1`** — Raw JSONL byte ranges from Claude Code's
  transcript file (the `.jsonl` files Claude Code writes to its own
  session log directory). Each delta is a sequence of complete JSONL
  lines. Concatenation is byte append. Materialization produces a valid
  JSONL transcript. This format is used for importing pre-existing
  Claude Code sessions into the context chain (archaeology, analytics
  on historical data, bootstrapping context for agents that previously
  ran outside Bureau). It is not the primary checkpoint format — live
  sessions use `events-v1`. See
  [Claude Code Session Transcript Reference](#claude-code-session-transcript-reference)
  for detailed format documentation.

- **`bureau-agent-v1`** — CBOR-encoded message arrays from Bureau's
  native agent loop. Each delta is a CBOR array of `llm.Message`
  structs (the LLM conversation, not the observation stream). Used when
  the native agent needs conversation-level context restoration (resume
  from the exact LLM state, not from the observation-level events).
  Context chains may mix `events-v1` and `bureau-agent-v1` commits for
  the same session: the observation stream checkpoints via `events-v1`,
  while conversation-level snapshots use `bureau-agent-v1`.

- Additional formats as new agent runtimes are added (codex, gemini,
  generic). Each format defines its own delta representation and
  concatenation rule.

Formats are versioned. When the format changes (fields added, structure
reorganized), a new version is introduced. Old deltas remain in their
original format; translation happens during materialization.

---

## The Agent Service

The agent service manages the context commit store, checkpointing,
materialization, and metadata. It extends the existing agent service
(`bureau-agent-service`) which already handles session tracking, context
key-value storage, and metrics aggregation.

### Checkpoint

Creates a new context commit. The caller has already stored the delta
artifact in the CAS.

**Request:**
- Parent commit ID (empty for root)
- Commit type (`delta`, `compaction`, `snapshot`)
- Artifact ref for the delta content
- Format identifier
- Template, principal, machine, session ID
- Checkpoint trigger reason
- Ticket ID, thread ID (optional associations)
- Summary
- Message count, token count

**Response:**
- The generated `ctx-*` ID

The agent service generates the ctx-* ID, records the metadata, and
returns the ID. The commit is immediately queryable.

### Materialize

Reconstructs the full conversation from a context chain.

**Request:**
- Context commit ID
- Desired output format
- Stop strategy: `compaction` (stop at nearest compaction, the default),
  `root` (full chain), or a specific `ctx-*` ID (stop at a particular
  ancestor)

**Response:**
- Artifact ref for the materialized conversation
- Message count, token count of the materialized result

**Process:**
1. Walk the parent chain from the requested commit to the stop point.
2. Fetch each delta artifact from the CAS.
3. Concatenate deltas in chain order using the format-specific
   concatenation rule.
4. If the requested output format differs from the stored format,
   translate during concatenation.
5. Store the materialized result as a snapshot artifact (cached — the
   materialization is a deterministic function of the chain).
6. Return the artifact ref.

Materialization from a compaction commit produces: compaction summary +
post-compaction deltas. The summary acts as the conversation prefix.
Materialization to root produces: all deltas from root to tip, ignoring
compaction boundaries. This preserves full-fidelity access to the
original conversation for archaeology, re-compaction, or audit.

The agent service caches materialized results. Repeated materializations
of the same commit with the same parameters return the cached artifact
without recomputation.

### Resolve

Finds the context commit for a given principal at a given time. Used
when context is not explicitly referenced (see
[Context Capture on Tickets](#context-capture-on-tickets)).

**Request:**
- Principal identifier
- Timestamp

**Response:**
- The `ctx-*` ID of the nearest checkpoint at or before the timestamp

The agent service maintains a per-principal checkpoint timeline
(an ordered list of (timestamp, ctx-*) pairs per active principal).
Resolution is a binary search.

### Show

Returns the metadata for a context commit.

**Request:**
- Context commit ID

**Response:**
- Full commit metadata (all fields from the data model)

### History

Returns the chain of commits leading to a given commit.

**Request:**
- Context commit ID
- Depth limit (optional)

**Response:**
- Ordered list of commit metadata, from the requested commit back
  toward root

### Update Metadata

Updates mutable metadata on a context commit. The artifact is immutable;
metadata (summary, tags) can be updated after creation.

**Request:**
- Context commit ID
- Fields to update (summary)

**Response:**
- Acknowledgment

This is how a batch summarization service annotates old commits: walk
the chain, generate summaries, call update-metadata for each commit.
The delta artifacts are untouched.

---

## Instantiation: Template + Context

A Bureau agent's operational identity is the pair (template, context):

- **Template** — what the agent *is*. The PrincipalAssignment and
  template hierarchy define the sandbox shape, entrypoint, credentials,
  required services, MCP configuration, and system prompt. The template
  is structural: it determines what the agent can do.

- **Context** — what the agent *knows*. A `ctx-*` reference pointing to
  a context commit. The materialized context is the agent's conversation
  history — everything it has seen, thought, and done up to that point.

A **principal** is where the pair runs. The principal provides a Matrix
account (for authentication), a sandbox (for isolation), a machine (for
compute), and a workspace (for file access). The principal is an
execution slot. It is informative, not definitional — the same
(template, context) pair can run on different principals, different
machines, at different times.

### Starting an Agent

When an agent needs to be started (StartCondition fires, review
discussion opens, ticket becomes ready), the system:

1. Identifies the template (from the PrincipalAssignment, or from a
   ticket's recorded template).
2. Identifies the context (from a `ctx-*` reference, or null for a
   fresh start).
3. Provisions a principal for the template (the fleet controller assigns
   a machine, the daemon creates the sandbox).
4. The agent wrapper loads the context:
   - Calls the agent service: `materialize(ctx-*, format)`.
   - Receives the materialized conversation artifact.
   - Initializes the agent runtime with the conversation as prefix.
5. The agent starts with full memory of its previous work.

### Fresh Start vs. Resume vs. Fork

These are not different operations — they are the same operation with
different context inputs:

- **Fresh start**: context is null. The agent begins with an empty
  conversation. A new chain starts.
- **Resume**: context is the agent's most recent commit (the tip of
  its chain). The agent continues where it left off.
- **Fork**: context is an arbitrary commit (possibly from another
  agent's chain). The agent starts a new branch from that understanding.

The agent wrapper does not need different code paths for these cases.
It always calls `materialize(ctx)` (which returns empty for null) and
initializes the runtime with the result.

### Example: Review Discussion

A reviewer creates finding TKT-F-1 with context `ctx-rev-003`. The
finding ticket records this context reference. Later, the author wants
to discuss the finding:

1. The system reads TKT-F-1, sees `ctx-rev-003` and the reviewer's
   template.
2. A principal is provisioned for the reviewer template (possibly on a
   different machine than the original review).
3. The wrapper calls `materialize(ctx-rev-003)` — the reviewer's full
   understanding at the point they wrote the finding.
4. The reviewer agent starts in a Matrix thread, reads the author's
   question, and replies with full memory of the review.
5. Each message in the thread creates a new context commit (branching
   from `ctx-rev-003`).
6. If the author also discusses TKT-F-2 (also referencing `ctx-rev-003`),
   a second branch starts from the same point. The two discussions are
   independent.

The reviewer does not need to be "running" between discussions. Its
understanding is stored in the context chain and loaded on demand.

---

## Context Capture

### Checkpoint Triggers

The agent wrapper checkpoints context at meaningful boundaries:

- **Turn boundary** — after the assistant finishes responding, before
  tool execution begins. This captures the agent's reasoning and
  decisions.
- **Tool result** — after a tool returns its result. This captures what
  the agent learned.
- **Compaction** — when the context manager compacts. The pre-compaction
  delta is saved, then a compaction commit is created.
- **Session end** — when the sandbox lifecycle ends (graceful exit or
  crash recovery). Final checkpoint.
- **Explicit** — the agent (or operator) requests a checkpoint via the
  agent service.

The frequency is configurable. The default (every turn boundary)
produces fine-grained chains. A coarser setting (every N turns, or only
on significant events) reduces checkpoint volume at the cost of
granularity.

### Capture by Runtime

**Bureau native agent** (`bureau-agent`): The agent loop manages
messages as Go structs in memory. At each checkpoint, it serializes
`messages[lastCheckpointIndex:]` to CBOR, stores the delta artifact,
and calls checkpoint on the agent service. No file I/O, no format
conversion.

**Claude Code** (`bureau-agent-claude`): The wrapper launches Claude
Code with `--output-format stream-json` and parses stdout line by line
via `ParseOutput`. Each stream-json line is a JSON object with a `type`
field; `ParseOutput` maps these to typed `agentdriver.Event` structs:

- `{"type":"system","subtype":"init",...}` → `EventTypeSystem` with
  full `Metadata` (session_id, tools, model). The `init` event fires
  once at startup and carries the session configuration.
- `{"type":"system","subtype":"compact_boundary",...}` → `EventTypeSystem`
  with `Metadata` containing `{"trigger":"auto","pre_tokens":N}`. This
  signals context window compaction.
- `{"type":"assistant","subtype":"text",...}` → `EventTypeResponse` with
  the agent's text output.
- `{"type":"assistant","subtype":"thinking",...}` → `EventTypeThinking`
  with chain-of-thought content and optional cryptographic signature.
- `{"type":"assistant","subtype":"tool_use",...}` → `EventTypeToolCall`
  with tool name, input, and the `tool_use_id` identifier.
- `{"type":"assistant","subtype":"server_tool_use",...}` →
  `EventTypeToolCall` with `ServerTool=true`. Server tools (web search,
  file search) use `"id"` instead of `"tool_use_id"` as the identifier
  field; the parser handles both.
- `{"type":"tool","subtype":"result",...}` → `EventTypeToolResult` with
  `tool_use_id`, `is_error`, and `content`.
- `{"type":"user",...}` → `EventTypePrompt` with `Source="user"`.
  Content may be a string or an array of content blocks; the parser
  concatenates text blocks. Note: in the stream-json output, `type:
  "user"` records appear only for actual human input injected via stdin.
  The many categories of system-injected content that appear as `type:
  "user"` in Claude Code's JSONL transcript files (tool results, context
  continuations, task notifications) are represented by their own
  event types in stream-json.
- `{"type":"result","subtype":"success"}` → `EventTypeMetric` with
  token counts, cost, duration, turn count, and `Status="success"`.
  Error variants (`error_max_turns`, `error_during_execution`,
  `error_max_budget_usd`) set Status to the subtype value.
- Unknown types → `EventTypeOutput` with the raw JSON preserved.

The event pump in `Run()` feeds each parsed event to an
`eventCheckpointTracker` that accumulates events and creates CBOR
delta checkpoints at three boundaries:

- **Turn boundary** (`ResponseEvent`): after the agent finishes a text
  response, capturing the complete turn (prompt, thinking, tool calls,
  tool results, response).
- **Compaction** (`SystemEvent` with `subtype: "compact_boundary"`):
  the context window was compacted. The pre-compaction events are
  checkpointed as a delta, and the compaction event itself marks the
  boundary.
- **Session end** (`MetricEvent`): the session is complete. A final
  checkpoint captures any trailing events.

Each checkpoint serializes `events[lastCheckpointIndex:]` to CBOR,
sends the bytes to the agent service (which stores them as an artifact
and records the commit metadata atomically), and chains the commit to
the previous checkpoint via the parent field. The format is `events-v1`.

The wrapper also disables Claude Code's non-essential network traffic
(`CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC`, `DISABLE_TELEMETRY`,
`DISABLE_ERROR_REPORTING`) to avoid startup delays inside sandboxes
where outbound connections are blocked.

**Other runtimes** (codex, gemini, generic): Each wrapper's Driver
implementation captures events in its native format and checkpoints
through the same agent service API. The format field varies; the chain
mechanics are identical.

### Context Capture on Tickets

When an agent modifies a ticket, the ticket should carry a reference to
the agent's context at that moment. This enables resumption: anyone
reading the ticket can identify the context and instantiate the agent
from that understanding.

The `context_id` field on `TicketContent` is an opaque string. The
ticket service stores it without interpretation. Consumers who want
the context request it from the agent service by ID.

**Requirements for the capture mechanism:**

- The ctx-* ID must represent the agent's understanding at the time
  of the ticket mutation, not at some earlier or later checkpoint.
- The mechanism must work for all agent runtimes (native, Claude Code,
  codex, generic) without runtime-specific special cases in the MCP
  server or ticket service.
- The MCP server and ticket service must not contain context capture
  logic. They handle only the final ctx-* ID string.
- The mechanism must work for both MCP tool calls and CLI invocations
  (`bureau ticket update ...`).

**Wrapper context socket (primary path):**

The wrapper exposes a Unix socket at `/run/bureau/agent-context.sock`
with a single unauthenticated action: `current-context`. No auth is
needed because the socket lives inside the sandbox namespace and is
unreachable from outside. The socket uses `lib/service.SocketServer`
with `Handle` (not `HandleAuth`).

Tools query the socket via `BUREAU_AGENT_CONTEXT_SOCKET` (set
automatically by `Run()` when checkpointing is enabled). The response
is `{"context_id": "ctx-..."}` — the ctx-* identifier of the most
recent checkpoint commit, or empty string if no checkpoint has fired.

Timing guarantee: checkpoints fire at `EventTypeResponse` (turn
boundary), before the agent begins tool execution. By the time a tool
queries the socket, the checkpoint has completed and the context ID is
settled. A mutex-guarded getter (`CurrentContextID()`) ensures
consistent reads even if a checkpoint is in-flight.

**Tool integration:**

Ticket mutation CLI commands (`create`, `update`, `close`, `reopen`,
`defer`) auto-detect the wrapper socket via the environment variable.
If present, they query it and include `context_id` in the mutation
request. If absent (outside sandbox), `context_id` is silently
omitted. The ticket service stores it on `TicketContent.ContextID`
(and on `TicketNote.ContextID` for add-note). The MCP server has no
context capture logic: tools inherit `BUREAU_AGENT_CONTEXT_SOCKET`
from the wrapper environment and query it like any CLI command.

**Resolve fallback (retrospective linking):**

For mutations made outside sandboxes (operator CLI, ticket service
backfill), the agent service's `resolve-context` endpoint finds the
nearest commit by principal and timestamp. This requires no explicit
capture — the join uses the principal identity and the timestamp of
the ticket mutation (which Matrix records on every state event).
Separate implementation.

---

## Format Versioning and Translation

Context artifacts in the CAS are immutable. Interpretation evolves.

When an agent requests materialization of a context chain whose format
differs from what the agent runtime expects, the agent service translates
during materialization. Translation has four tiers, applied in order
of preference:

1. **Native load.** Format matches the requesting runtime. Concatenate
   deltas and return. The fast path.

2. **Field-level translation.** Format is an older version of the same
   runtime's format. The agent service maps fields (renames, restructures,
   adjusts tool call representations) during concatenation. The chain
   stays in the original format; the output is in the new format.

3. **Rendering.** Format is structurally different (different runtime, or
   a version gap too large for field mapping). The agent service extracts
   the human-readable content from each delta — message text, tool names
   and descriptions, summaries — and produces a structured narrative.
   The agent receives "here is what the previous session knew" as context
   rather than a native conversation to continue from.

4. **Raw fallback.** Format is completely unknown. The agent service
   returns the raw artifacts. An LLM agent given a JSON or CBOR
   transcript with a description of the format will extract useful
   information even without native parsing.

The tier is determined by the agent service based on the stored format
and the requested format. Translated materializations are cached as
snapshot artifacts, so the translation cost is paid once per
(chain, target-format) pair.

### Batch Summarization

A background service can walk old context chains, generate summaries
for commits that lack them, and call update-metadata. This runs on
cheap compute (small models are sufficient for summarization). The
service:

1. Queries the agent service for commits without summaries.
2. Materializes each commit (or reads its delta directly for per-commit
   summaries).
3. Generates a summary via an LLM call.
4. Updates the commit metadata with the summary.

Summaries make chains browsable without materialization. A PM agent or
operator can read the chain history (commit messages, like `git log`)
to understand what happened without loading the full conversation.

---

## Storage Efficiency

### Delta vs. Full Snapshot

Each context commit stores only the delta since its parent. A 100-turn
conversation with 20 checkpoints stores approximately 100 turns of data
total — each turn appears in exactly one delta. Compare to full
snapshots: 20 checkpoints of an increasingly large conversation would
store the sum 5+10+15+...+100 = 1050 turns of data, 10x more.

CDC chunking in the CAS provides additional deduplication if deltas
happen to share content (e.g., repeated system prompts, identical tool
outputs). But the delta model provides the primary storage efficiency;
CAS dedup is a bonus, not a requirement.

### Compaction and Chain Depth

Long-running agents produce deep chains. Materialization walks the
full chain (or to the nearest compaction), fetching one artifact per
commit. For chains of hundreds of commits, this is hundreds of CAS
reads.

Compaction commits bound the walk depth. After compaction, new deltas
build from the compaction point. Materialization fetches the compaction
summary plus post-compaction deltas — typically a small number.

For archival chains that will never be materialized (only browsed via
summaries), the chain depth is irrelevant. For chains that need fast
materialization, operators or the batch service can create snapshot
commits (full materializations stored as single artifacts) that act as
optimization points, similar to git packfiles.

### Garbage Collection

Context artifacts follow the same lifecycle policies as other artifacts
in the CAS: default (LRU), pin, ephemeral, replicate. Context commits
whose artifacts have been evicted from the local cache can be
re-fetched from shared or backing stores. Commit metadata in the agent
service is lightweight and retained independently of artifact
availability.

---

## Integration with Tickets

### The `context_id` Field

`TicketContent` includes a `context_id` string field. The ticket service
treats it as an opaque value — it stores and returns it without
interpretation.

When an agent creates or updates a ticket, the mutation includes the
agent's current context ID. Consumers who read the ticket and want the
context use the ID to query the agent service.

The Matrix timeline preserves every version of every state event.
Each version records the sender (principal) and timestamp. Combined
with the `context_id` field, this gives a complete record: who changed
the ticket, when, and what they understood at that moment.

### Code Review Workflow

The review workflow is a primary consumer of the context system. See
[tickets.md](tickets.md) for the ticket mechanics (review status,
reviewer tracking, findings as child tickets). The context system
provides:

- **Reviewer context on findings.** When the reviewer creates a finding,
  the finding ticket carries `context_id` pointing to the reviewer's
  understanding at that moment.

- **Discussion via thread resumption.** When the author starts a thread
  on a finding, the system reads the `context_id`, materializes the
  reviewer's context, and starts a new agent instance from that point.
  The thread conversation creates a new branch in the context chain.

- **Resolution verification.** When the author closes a finding with a
  resolution, the reviewer can be resumed from the discussion chain's
  tip context. The reviewer evaluates the fix with full memory of the
  finding, the discussion, and the code.

- **Author context on the parent ticket.** The author's own context is
  captured when they update the parent ticket. If the author gets
  reassigned or the ticket goes dormant, the next agent can load the
  author's context to understand where things stand.

### Event-Driven Lifecycle

Context and tickets compose with the existing event-driven agent
lifecycle:

1. Agent works on ticket, checkpointing context at each turn boundary.
2. Agent transitions ticket to `review`, exits. Context chain captures
   the full session.
3. PM assigns reviewers. Reviewer agents trigger via StartCondition.
4. Each reviewer loads a fresh context (or resumes from a previous
   review of the same ticket), examines the code, creates findings with
   context references.
5. Author triggers on ticket returning to `in_progress`. Reads findings,
   works through them.
6. Author asks for clarification on a finding — thread starts, reviewer
   resumes from the finding's context. They discuss in the thread, each
   message checkpointing context.
7. Author closes findings. Reviewer verifies from discussion context.
8. All findings addressed, review approved, ticket closes.

No agent runs during the waiting periods. Context is stored in the
chain. Agents start fresh with full memory when triggered.

---

## Claude Code Session Transcript Reference

Claude Code maintains its own session transcript files as JSONL (one
JSON object per line) in `~/.claude/projects/<project-hash>/<uuid>.jsonl`.
These are distinct from Bureau's `events-v1` checkpoint artifacts. This
section documents the raw JSONL format for implementors of the
`claude-code-v1` import format and for anyone building analytics over
historical Claude Code sessions.

### JSONL Record Types

Each line has a top-level `type` field:

- **`assistant`** — Model output. Contains `message` with `content`
  blocks (text, tool_use, thinking). Also carries `costUSD`,
  `inputTokens`, `outputTokens`, `cacheReadInputTokens`,
  `cacheCreationInputTokens`, and the `model` identifier.

- **`user`** — Overloaded: see
  [The User Record Classification Problem](#the-user-record-classification-problem).
  In principle represents human input, but the majority of `type:
  "user"` records are not human-originated.

- **`system`** — System events. The `subtype` field classifies them:
  `compact_boundary` (context compaction with `trigger` and
  `pre_tokens`), `microcompact_boundary` (lighter compaction variant),
  `context_truncated`, `init`. The `compact_boundary` subtype is the
  primary signal for context management events.

- **`result`** — Session completion. Contains `subtype` (`success`,
  `error_max_turns`, `error_during_execution`, `error_max_budget_usd`),
  token counts, cost, duration, and turn count. One per session.

- **`progress`** — Intermediate progress updates during long-running
  tool executions. Not conversation content.

- **`summary`** — Context continuation summaries written when a session
  is continued from a previous conversation that ran out of context.
  These are large (often 10K+ characters) and contain the compressed
  history of the prior session.

- **`file-history-snapshot`** — Periodic snapshots of file state for
  change tracking.

- **`queue-operation`** — Internal queue state changes (e.g., message
  queue flushes in team workflows).

### The User Record Classification Problem

The `type: "user"` field in Claude Code's JSONL is massively overloaded.
A naive count of `type: "user"` records in a real dataset (697 sessions
across three projects) yielded 149,647 "human prompts" — the actual
count was 7,778. The remaining 141,869 records were:

- **Tool results** (~138K records): Each tool invocation returns its
  result as a `type: "user"` record whose `content` is an array
  containing only `tool_result` blocks. These are the bulk of the
  overcounting.

- **System-injected content** (~3.9K records): Various system messages
  delivered as `type: "user"` records. These include:
  - Context continuation summaries (prefixed "This session is being
    continued from a previous conversation that ran out of context")
  - Task notifications (`<task-notification>` tags)
  - Skill injections ("Base directory for this skill:")
  - Teammate messages (`<teammate-message` tags)
  - Local command boilerplate (`<local-command-caveat>`,
    `<local-command-stdout>`, `<local-command-stderr>`, `<command-name>`,
    `<command-message>` tags)
  - Bash output injection (`<bash-input>`, `<bash-stdout>` tags)
  - Auto-continuation prompts ("Continue from where you left off.")

The `events-v1` format avoids this problem entirely: the Claude Code
wrapper parses `stream-json` output (not the JSONL transcript), where
each event type has its own `type` field. Tool results arrive as
`{"type":"tool","subtype":"result"}`, human input as
`{"type":"user"}`, and system events as `{"type":"system"}`.

For `claude-code-v1` import (ingesting historical sessions), the
ingestion pipeline must classify `type: "user"` records:

- If `content` is a list containing only `tool_result` blocks →
  `EventTypeToolResult`.
- If `content` matches a system-injected pattern (see list above) →
  skip or tag as system metadata.
- Otherwise → `EventTypePrompt` (actual human input).

### Sidechain Agents and Session Structure

Claude Code sessions may spawn sub-agents (via the Task tool). These
appear in the JSONL with `isSidechain: true` and an `agentId` field on
their records. A single JSONL file may contain the main conversation
plus multiple sidechain agent transcripts interleaved by timestamp.

For import, sidechain agent records should be separated into their own
context chains (branching from the parent's chain at the point the
sub-agent was spawned). The `agentId` field provides the grouping key.

Records with `isMeta: true` are system-generated metadata (e.g.,
permission grants, configuration changes) and do not represent
conversation content.

### Compaction in JSONL Transcripts

Context compaction appears as a `type: "system"` record with
`subtype: "compact_boundary"`. The record's content includes `trigger`
(usually `"auto"`) and `pre_tokens` (the token count before
compaction). A `microcompact_boundary` subtype represents a lighter
compaction variant.

After a `compact_boundary`, the next `type: "summary"` record (if
present) contains the compaction summary that replaces the pre-boundary
conversation. For `claude-code-v1` import, this maps to a compaction
commit in the context chain.

In a dataset of 697 sessions, 42.5% hit at least one compaction (1,427
total compactions). The most-compacted session had 71 compactions over
77 hours. No session reached 20 human prompts without compacting — the
context window is the binding constraint for sustained work.

---

## Analytics Derivability

Context chains stored via `events-v1` support automated analytics
without re-parsing raw transcripts. The structured event types map
directly to the metrics that matter for understanding agent workflows:

**Session profiles.** Each `Event` has a timestamp and type. Binning
events into time windows and classifying by type (human prompt, agent
response, tool call, thinking, compaction, idle gaps) produces
thread-scheduler-style session timelines. These visualize when the human
was active, when the agent was working, and when context was being
managed.

**Amplification metrics.** Counting `EventTypePrompt` (human input),
`EventTypeResponse` (agent output), and `EventTypeToolCall` (tool
invocations) per session yields the amplification ratio: how many agent
actions each human direction triggers. In the Bureau project data, this
was 35.5x responses per prompt and 18 tool operations per human
direction. Character ratios (human input characters vs. agent output
characters) quantify the leverage differently — 8.3x in the same
dataset.

**Compaction frequency.** `EventTypeSystem` with `subtype:
"compact_boundary"` marks each compaction. Counting these per session
and correlating with session duration reveals the context window
pressure curve: how quickly different workloads exhaust the context
budget.

**Activity patterns.** Event timestamps aggregated by hour-of-day and
day-of-week produce heatmaps showing when work happens. Peak concurrent
sessions (overlapping session time ranges) reveal parallelism patterns.

**Tool usage distribution.** `ToolCallEvent.Name` frequencies show which
tools the agent uses most and how tool patterns differ across templates
(reviewers use Read heavily; implementers use Edit and Bash).

**Session lifecycle.** `MetricEvent.Status` classifies session outcomes
(success, error_max_turns, error_during_execution). Combined with
session duration (first event timestamp to `MetricEvent` timestamp) and
compaction count, this characterizes session health.

The batch summarization service and analytics pipeline consume these
metrics from the context chain without needing access to the live agent
or the original runtime transcript files. The `events-v1` format is
both the persistence layer and the analytics source.

---

## Relationship to Other Design Documents

- [agent-layering.md](agent-layering.md) — wrapper binaries, the Driver
  interface, session log format, and the agent service's existing
  session/context/metrics APIs. This document extends that foundation
  with chain-based context commits and materialization.

- [tickets.md](tickets.md) — the `context_id` field on TicketContent,
  the review status and workflow, finding tickets as children. The
  context system provides the resumption mechanism that makes review
  discussions work.

- [artifacts.md](artifacts.md) — context deltas, compaction summaries,
  and materialized snapshots are all artifacts in the CAS. The CAS
  provides content-addressed storage, chunk-level deduplication, and
  tiered caching. The context system is a consumer of the artifact
  service.

- [architecture.md](architecture.md) — the daemon provisions principals
  for (template, context) instantiation. The fleet controller assigns
  machines. Service sockets for the agent service and artifact service
  are bind-mounted into sandboxes.

- [information-architecture.md](information-architecture.md) — context
  commit metadata is stored as CBOR artifacts in the CAS, tagged as
  `ctx/<commitID>`, managed by the agent service. Thread conversations
  (Level 3 in the information architecture) are the medium for review
  discussions that drive context chain branching.
