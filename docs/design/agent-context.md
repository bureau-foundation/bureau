# Agent Context

[agent-layering.md](agent-layering.md) describes how agents are wrapped,
executed, and observed. [tickets.md](tickets.md) describes work items,
dependencies, and coordination. This document describes agent context:
the system for capturing, storing, forking, and resuming an agent's
accumulated understanding across sandbox lifecycles, machines, and time.

---

## Why Context

When an agent works on a problem, it builds understanding: which files
matter, what the code does, where the bug is, why the previous approach
didn't work. Today this understanding exists only in the LLM's context
window for the duration of a single sandbox lifecycle. When the sandbox
exits — task complete, crash, preemption, compaction — the understanding
is gone.

This creates three problems:

- **No resumption.** An agent that exits mid-task starts from scratch
  next time. It re-reads the same files, re-discovers the same
  constraints, re-makes the same decisions. This wastes tokens, time,
  and money.

- **No collaboration.** When a reviewer finds a bug and the author wants
  to ask "what do you mean?", the reviewer's understanding doesn't exist
  anymore. The author gets a cold finding ticket with a description, not
  a conversation partner who remembers the code, the intent, and the
  tradeoffs they considered.

- **No accountability.** After the fact, "why did the agent do this?"
  has no answer. The reasoning that led to a decision evaporated with
  the sandbox.

Agent context solves these by making an agent's understanding a
first-class, storable, resumable, forkable artifact.

---

## Core Concepts

### Context Commits

A context commit is a snapshot of an agent's understanding at a specific
point in time. It is the fundamental unit of the context system.

Each context commit contains:

- **A delta** — the new conversation entries (messages, tool calls, tool
  results) since the parent commit. Not a full snapshot; just what's new.

- **A parent** — the previous context commit in the chain. Null for the
  root of a new conversation.

- **Provenance** — which agent template produced this, which principal
  executed it, on which machine, in which session. The template is
  structural (what kind of agent); the principal and machine are
  informative (where it happened to run).

- **A summary** — a human-readable description of the agent's
  understanding at this point. Always present, always readable regardless
  of format version. Can be generated at commit time or added later by a
  batch summarization service.

Context commits are stored as artifacts in the CAS (content-addressed
storage). Each commit's delta is an artifact; the commit metadata
(parent, provenance, summary) lives in the agent service.

### The `ctx-*` ID Scheme

Context commits are identified by `ctx-` prefixed short IDs, following
the same pattern as `tkt-` (tickets) and `art-` (artifacts). A ctx-*
ID is the logical handle for a context commit. It resolves to commit
metadata in the agent service, which includes the artifact ref for the
delta content.

The ID is generated by the agent service from deterministic inputs
(parent ref, artifact ref, timestamp, template). It is unambiguous —
`ctx-` does not collide with `tkt-`, `art-`, or Matrix identifiers.

### Chains

Context commits form chains through parent links, analogous to git
commits. A chain represents the evolution of an agent's understanding
over the course of a task:

```
ctx-a001 (root: messages 1-5)
  └→ ctx-a002 (delta: messages 6-10)
       └→ ctx-a003 (delta: messages 11-15)
            └→ ctx-a004 (delta: messages 16-20)
```

Each commit stores only the delta. The full conversation at any point
is the concatenation of all deltas from root to that commit. This gives
storage proportional to the total conversation size, not proportional
to the number of checkpoints times the conversation size.

### Branching and Forking

Two context commits can share the same parent. This happens naturally
when an agent's understanding at one point leads to multiple independent
conversations:

```
ctx-a003 (reviewer's understanding after examining code)
  ├→ ctx-b001 (discussion thread about finding #1)
  │    └→ ctx-b002 (continued discussion)
  └→ ctx-c001 (discussion thread about finding #2)
       └→ ctx-c002 (continued discussion)
```

Each branch is an independent conversation that diverges from a shared
starting point. The reviewer in the finding #1 discussion never sees
messages from the finding #2 discussion, and vice versa — they are
separate agent instances with separate chains.

Branching is not a special operation. It is the natural result of two
context commits naming the same parent. The agent service does not
enforce or prevent it.

### Compaction Commits

LLM context windows are finite, and model performance degrades as
context grows. Agents compact their context — summarizing older
conversation to make room for new work. The context chain captures
compaction as a special commit type:

```
ctx-a001 (delta: messages 1-10)
  └→ ctx-a002 (delta: messages 11-20)
       └→ ctx-a003 (delta: messages 21-30)
            └→ ctx-a004 (COMPACTION: summary of messages 1-30)
                 └→ ctx-a005 (delta: messages 31-35, post-compaction)
```

A compaction commit's artifact is the summary that replaces the prefix,
not a delta of new messages. It acts as a reset point in the chain:
default materialization stops at the nearest compaction and uses the
summary as the conversation prefix. The full pre-compaction history
remains reachable by walking past the compaction node.

Compaction commits are created when:

- The LLM runtime compacts (Anthropic's server-side compaction, Claude
  Code's `/compact`, the native agent's context manager dropping turn
  groups).

- An operator or batch service explicitly compacts an old chain
  (re-summarizing with a newer model for better fidelity).

The pre-compaction delta is always checkpointed before the compaction
commit, so the full conversation is preserved in the chain even though
the live agent only sees the summary going forward.

---

## Data Model

### Context Commit Metadata

The agent service stores metadata for each context commit:

- **ID** — `ctx-*` identifier.
- **Parent** — parent commit ID. Empty for root commits.
- **CommitType** — `delta`, `compaction`, or `snapshot`.
  - `delta`: the artifact contains new conversation entries since the
    parent.
  - `compaction`: the artifact contains a summary replacing the prefix
    chain. Materialization stops here by default.
  - `snapshot`: a full materialized context stored as a single artifact,
    used for caching or for contexts imported from external systems.
- **ArtifactRef** — BLAKE3 ref pointing to the delta (or compaction
  summary, or full snapshot) in the CAS.
- **Format** — the serialization format of the delta. Determines how
  deltas are concatenated during materialization and how translation
  works.
- **Template** — the agent template that produced this commit. Structural
  identity: what kind of agent this is.
- **Principal** — the principal that executed this commit. Informative:
  where it ran.
- **Machine** — the machine the principal ran on. Informative.
- **SessionID** — the session within which this commit was created.
- **Checkpoint** — what triggered this commit: `turn_boundary`,
  `tool_call`, `compaction`, `session_end`, `explicit`.
- **TicketID** — the ticket being worked, if applicable.
- **ThreadID** — the Matrix thread, if this commit is part of a thread
  conversation.
- **Summary** — human-readable description of the agent's understanding.
  Mutable (can be added or updated after creation). The artifact is
  immutable; the summary is metadata.
- **MessageCount** — number of messages in this delta.
- **TokenCount** — approximate token count of this delta.
- **CreatedAt** — ISO 8601 timestamp.

### Delta Formats

The delta artifact format is agent-runtime-specific. The `format` field
on the commit tells the agent service how to concatenate deltas during
materialization:

- **`claude-code-v1`** — JSONL byte ranges from Claude Code's
  transcript file. Each delta is a sequence of complete JSONL lines.
  Concatenation is byte append. Materialization produces a valid JSONL
  transcript.

- **`bureau-agent-v1`** — CBOR-encoded message arrays from Bureau's
  native agent loop. Each delta is a CBOR array of message structs.
  Concatenation decodes and merges arrays.

- Additional formats as new agent runtimes are added (codex, gemini,
  generic). Each format defines its own delta representation and
  concatenation rule.

Formats are versioned. When the format changes (fields added, structure
reorganized), a new version is introduced. Old deltas remain in their
original format; translation happens during materialization.

---

## The Agent Service

The agent service manages the context commit store, checkpointing,
materialization, and metadata. It extends the existing agent service
(`bureau-agent-service`) which already handles session tracking, context
key-value storage, and metrics aggregation.

### Checkpoint

Creates a new context commit. The caller has already stored the delta
artifact in the CAS.

**Request:**
- Parent commit ID (empty for root)
- Commit type (`delta`, `compaction`, `snapshot`)
- Artifact ref for the delta content
- Format identifier
- Template, principal, machine, session ID
- Checkpoint trigger reason
- Ticket ID, thread ID (optional associations)
- Summary
- Message count, token count

**Response:**
- The generated `ctx-*` ID

The agent service generates the ctx-* ID, records the metadata, and
returns the ID. The commit is immediately queryable.

### Materialize

Reconstructs the full conversation from a context chain.

**Request:**
- Context commit ID
- Desired output format
- Stop strategy: `compaction` (stop at nearest compaction, the default),
  `root` (full chain), or a specific `ctx-*` ID (stop at a particular
  ancestor)

**Response:**
- Artifact ref for the materialized conversation
- Message count, token count of the materialized result

**Process:**
1. Walk the parent chain from the requested commit to the stop point.
2. Fetch each delta artifact from the CAS.
3. Concatenate deltas in chain order using the format-specific
   concatenation rule.
4. If the requested output format differs from the stored format,
   translate during concatenation.
5. Store the materialized result as a snapshot artifact (cached — the
   materialization is a deterministic function of the chain).
6. Return the artifact ref.

Materialization from a compaction commit produces: compaction summary +
post-compaction deltas. The summary acts as the conversation prefix.
Materialization to root produces: all deltas from root to tip, ignoring
compaction boundaries. This preserves full-fidelity access to the
original conversation for archaeology, re-compaction, or audit.

The agent service caches materialized results. Repeated materializations
of the same commit with the same parameters return the cached artifact
without recomputation.

### Resolve

Finds the context commit for a given principal at a given time. Used
when context is not explicitly referenced (see
[Context Capture on Tickets](#context-capture-on-tickets)).

**Request:**
- Principal identifier
- Timestamp

**Response:**
- The `ctx-*` ID of the nearest checkpoint at or before the timestamp

The agent service maintains a per-principal checkpoint timeline
(an ordered list of (timestamp, ctx-*) pairs per active principal).
Resolution is a binary search.

### Show

Returns the metadata for a context commit.

**Request:**
- Context commit ID

**Response:**
- Full commit metadata (all fields from the data model)

### History

Returns the chain of commits leading to a given commit.

**Request:**
- Context commit ID
- Depth limit (optional)

**Response:**
- Ordered list of commit metadata, from the requested commit back
  toward root

### Update Metadata

Updates mutable metadata on a context commit. The artifact is immutable;
metadata (summary, tags) can be updated after creation.

**Request:**
- Context commit ID
- Fields to update (summary)

**Response:**
- Acknowledgment

This is how a batch summarization service annotates old commits: walk
the chain, generate summaries, call update-metadata for each commit.
The delta artifacts are untouched.

---

## Instantiation: Template + Context

A Bureau agent's operational identity is the pair (template, context):

- **Template** — what the agent *is*. The PrincipalAssignment and
  template hierarchy define the sandbox shape, entrypoint, credentials,
  required services, MCP configuration, and system prompt. The template
  is structural: it determines what the agent can do.

- **Context** — what the agent *knows*. A `ctx-*` reference pointing to
  a context commit. The materialized context is the agent's conversation
  history — everything it has seen, thought, and done up to that point.

A **principal** is where the pair runs. The principal provides a Matrix
account (for authentication), a sandbox (for isolation), a machine (for
compute), and a workspace (for file access). The principal is an
execution slot. It is informative, not definitional — the same
(template, context) pair can run on different principals, different
machines, at different times.

### Starting an Agent

When an agent needs to be started (StartCondition fires, review
discussion opens, ticket becomes ready), the system:

1. Identifies the template (from the PrincipalAssignment, or from a
   ticket's recorded template).
2. Identifies the context (from a `ctx-*` reference, or null for a
   fresh start).
3. Provisions a principal for the template (the fleet controller assigns
   a machine, the daemon creates the sandbox).
4. The agent wrapper loads the context:
   - Calls the agent service: `materialize(ctx-*, format)`.
   - Receives the materialized conversation artifact.
   - Initializes the agent runtime with the conversation as prefix.
5. The agent starts with full memory of its previous work.

### Fresh Start vs. Resume vs. Fork

These are not different operations — they are the same operation with
different context inputs:

- **Fresh start**: context is null. The agent begins with an empty
  conversation. A new chain starts.
- **Resume**: context is the agent's most recent commit (the tip of
  its chain). The agent continues where it left off.
- **Fork**: context is an arbitrary commit (possibly from another
  agent's chain). The agent starts a new branch from that understanding.

The agent wrapper does not need different code paths for these cases.
It always calls `materialize(ctx)` (which returns empty for null) and
initializes the runtime with the result.

### Example: Review Discussion

A reviewer creates finding TKT-F-1 with context `ctx-rev-003`. The
finding ticket records this context reference. Later, the author wants
to discuss the finding:

1. The system reads TKT-F-1, sees `ctx-rev-003` and the reviewer's
   template.
2. A principal is provisioned for the reviewer template (possibly on a
   different machine than the original review).
3. The wrapper calls `materialize(ctx-rev-003)` — the reviewer's full
   understanding at the point they wrote the finding.
4. The reviewer agent starts in a Matrix thread, reads the author's
   question, and replies with full memory of the review.
5. Each message in the thread creates a new context commit (branching
   from `ctx-rev-003`).
6. If the author also discusses TKT-F-2 (also referencing `ctx-rev-003`),
   a second branch starts from the same point. The two discussions are
   independent.

The reviewer does not need to be "running" between discussions. Its
understanding is stored in the context chain and loaded on demand.

---

## Context Capture

### Checkpoint Triggers

The agent wrapper checkpoints context at meaningful boundaries:

- **Turn boundary** — after the assistant finishes responding, before
  tool execution begins. This captures the agent's reasoning and
  decisions.
- **Tool result** — after a tool returns its result. This captures what
  the agent learned.
- **Compaction** — when the context manager compacts. The pre-compaction
  delta is saved, then a compaction commit is created.
- **Session end** — when the sandbox lifecycle ends (graceful exit or
  crash recovery). Final checkpoint.
- **Explicit** — the agent (or operator) requests a checkpoint via the
  agent service.

The frequency is configurable. The default (every turn boundary)
produces fine-grained chains. A coarser setting (every N turns, or only
on significant events) reduces checkpoint volume at the cost of
granularity.

### Capture by Runtime

**Bureau native agent** (`bureau-agent`): The agent loop manages
messages as Go structs in memory. At each checkpoint, it serializes
`messages[lastCheckpointIndex:]` to CBOR, stores the delta artifact,
and calls checkpoint on the agent service. No file I/O, no format
conversion.

**Claude Code** (`bureau-agent-claude`): The wrapper parses Claude
Code's stream-json output via `ParseOutput`. At each checkpoint, it
serializes the events accumulated since the last checkpoint, stores the
delta artifact, and calls checkpoint on the agent service. The delta is
the structured events the wrapper has already parsed — not a re-read of
the transcript file.

**Other runtimes** (codex, gemini, generic): Each wrapper's Driver
implementation captures events in its native format and checkpoints
through the same agent service API. The format field varies; the chain
mechanics are identical.

### Context Capture on Tickets

When an agent modifies a ticket, the ticket should carry a reference to
the agent's context at that moment. This enables resumption: anyone
reading the ticket can identify the context and instantiate the agent
from that understanding.

The `context_id` field on `TicketContent` is an opaque string. The
ticket service stores it without interpretation. Consumers who want
the context request it from the agent service by ID.

**Requirements for the capture mechanism:**

- The ctx-* ID must represent the agent's understanding at the time
  of the ticket mutation, not at some earlier or later checkpoint.
- The mechanism must work for all agent runtimes (native, Claude Code,
  codex, generic) without runtime-specific special cases in the MCP
  server or ticket service.
- The MCP server and ticket service must not contain context capture
  logic. They handle only the final ctx-* ID string.
- The mechanism must work for both MCP tool calls and CLI invocations
  (`bureau ticket update ...`).

**Approaches under consideration:**

The fundamental challenge is that for external-process runtimes (Claude
Code, Codex), the entity with the context state (the wrapper) and the
entity performing ticket mutations (the MCP tool or CLI) are in
different processes. For the native agent they are the same process and
the problem is trivial. Several approaches bridge this gap with
different tradeoff profiles; the choice depends on what the wrapper
architecture can support at the point of integration. The agent service's
`resolve` endpoint (find context by principal and timestamp) provides a
fallback that requires no explicit capture — the join uses the principal
identity and event timestamp that Matrix already records on every state
event.

---

## Format Versioning and Translation

Context artifacts in the CAS are immutable. Interpretation evolves.

When an agent requests materialization of a context chain whose format
differs from what the agent runtime expects, the agent service translates
during materialization. Translation has four tiers, applied in order
of preference:

1. **Native load.** Format matches the requesting runtime. Concatenate
   deltas and return. The fast path.

2. **Field-level translation.** Format is an older version of the same
   runtime's format. The agent service maps fields (renames, restructures,
   adjusts tool call representations) during concatenation. The chain
   stays in the original format; the output is in the new format.

3. **Rendering.** Format is structurally different (different runtime, or
   a version gap too large for field mapping). The agent service extracts
   the human-readable content from each delta — message text, tool names
   and descriptions, summaries — and produces a structured narrative.
   The agent receives "here is what the previous session knew" as context
   rather than a native conversation to continue from.

4. **Raw fallback.** Format is completely unknown. The agent service
   returns the raw artifacts. An LLM agent given a JSON or CBOR
   transcript with a description of the format will extract useful
   information even without native parsing.

The tier is determined by the agent service based on the stored format
and the requested format. Translated materializations are cached as
snapshot artifacts, so the translation cost is paid once per
(chain, target-format) pair.

### Batch Summarization

A background service can walk old context chains, generate summaries
for commits that lack them, and call update-metadata. This runs on
cheap compute (small models are sufficient for summarization). The
service:

1. Queries the agent service for commits without summaries.
2. Materializes each commit (or reads its delta directly for per-commit
   summaries).
3. Generates a summary via an LLM call.
4. Updates the commit metadata with the summary.

Summaries make chains browsable without materialization. A PM agent or
operator can read the chain history (commit messages, like `git log`)
to understand what happened without loading the full conversation.

---

## Storage Efficiency

### Delta vs. Full Snapshot

Each context commit stores only the delta since its parent. A 100-turn
conversation with 20 checkpoints stores approximately 100 turns of data
total — each turn appears in exactly one delta. Compare to full
snapshots: 20 checkpoints of an increasingly large conversation would
store the sum 5+10+15+...+100 = 1050 turns of data, 10x more.

CDC chunking in the CAS provides additional deduplication if deltas
happen to share content (e.g., repeated system prompts, identical tool
outputs). But the delta model provides the primary storage efficiency;
CAS dedup is a bonus, not a requirement.

### Compaction and Chain Depth

Long-running agents produce deep chains. Materialization walks the
full chain (or to the nearest compaction), fetching one artifact per
commit. For chains of hundreds of commits, this is hundreds of CAS
reads.

Compaction commits bound the walk depth. After compaction, new deltas
build from the compaction point. Materialization fetches the compaction
summary plus post-compaction deltas — typically a small number.

For archival chains that will never be materialized (only browsed via
summaries), the chain depth is irrelevant. For chains that need fast
materialization, operators or the batch service can create snapshot
commits (full materializations stored as single artifacts) that act as
optimization points, similar to git packfiles.

### Garbage Collection

Context artifacts follow the same lifecycle policies as other artifacts
in the CAS: default (LRU), pin, ephemeral, replicate. Context commits
whose artifacts have been evicted from the local cache can be
re-fetched from shared or backing stores. Commit metadata in the agent
service is lightweight and retained independently of artifact
availability.

---

## Integration with Tickets

### The `context_id` Field

`TicketContent` includes a `context_id` string field. The ticket service
treats it as an opaque value — it stores and returns it without
interpretation.

When an agent creates or updates a ticket, the mutation includes the
agent's current context ID. Consumers who read the ticket and want the
context use the ID to query the agent service.

The Matrix timeline preserves every version of every state event.
Each version records the sender (principal) and timestamp. Combined
with the `context_id` field, this gives a complete record: who changed
the ticket, when, and what they understood at that moment.

### Code Review Workflow

The review workflow is a primary consumer of the context system. See
[tickets.md](tickets.md) for the ticket mechanics (review status,
reviewer tracking, findings as child tickets). The context system
provides:

- **Reviewer context on findings.** When the reviewer creates a finding,
  the finding ticket carries `context_id` pointing to the reviewer's
  understanding at that moment.

- **Discussion via thread resumption.** When the author starts a thread
  on a finding, the system reads the `context_id`, materializes the
  reviewer's context, and starts a new agent instance from that point.
  The thread conversation creates a new branch in the context chain.

- **Resolution verification.** When the author closes a finding with a
  resolution, the reviewer can be resumed from the discussion chain's
  tip context. The reviewer evaluates the fix with full memory of the
  finding, the discussion, and the code.

- **Author context on the parent ticket.** The author's own context is
  captured when they update the parent ticket. If the author gets
  reassigned or the ticket goes dormant, the next agent can load the
  author's context to understand where things stand.

### Event-Driven Lifecycle

Context and tickets compose with the existing event-driven agent
lifecycle:

1. Agent works on ticket, checkpointing context at each turn boundary.
2. Agent transitions ticket to `review`, exits. Context chain captures
   the full session.
3. PM assigns reviewers. Reviewer agents trigger via StartCondition.
4. Each reviewer loads a fresh context (or resumes from a previous
   review of the same ticket), examines the code, creates findings with
   context references.
5. Author triggers on ticket returning to `in_progress`. Reads findings,
   works through them.
6. Author asks for clarification on a finding — thread starts, reviewer
   resumes from the finding's context. They discuss in the thread, each
   message checkpointing context.
7. Author closes findings. Reviewer verifies from discussion context.
8. All findings addressed, review approved, ticket closes.

No agent runs during the waiting periods. Context is stored in the
chain. Agents start fresh with full memory when triggered.

---

## Relationship to Other Design Documents

- [agent-layering.md](agent-layering.md) — wrapper binaries, the Driver
  interface, session log format, and the agent service's existing
  session/context/metrics APIs. This document extends that foundation
  with chain-based context commits and materialization.

- [tickets.md](tickets.md) — the `context_id` field on TicketContent,
  the review status and workflow, finding tickets as children. The
  context system provides the resumption mechanism that makes review
  discussions work.

- [artifacts.md](artifacts.md) — context deltas, compaction summaries,
  and materialized snapshots are all artifacts in the CAS. The CAS
  provides content-addressed storage, chunk-level deduplication, and
  tiered caching. The context system is a consumer of the artifact
  service.

- [architecture.md](architecture.md) — the daemon provisions principals
  for (template, context) instantiation. The fleet controller assigns
  machines. Service sockets for the agent service and artifact service
  are bind-mounted into sandboxes.

- [information-architecture.md](information-architecture.md) — context
  metadata is stored as Matrix state events via the agent service.
  Thread conversations (Level 3 in the information architecture) are
  the medium for review discussions that drive context chain branching.
