// Copyright 2026 The Bureau Authors
// SPDX-License-Identifier: Apache-2.0

package bootstrap

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/bureau-foundation/bureau/lib/ref"
)

// Config is the bootstrap configuration transferred from the hub to a
// new machine. It contains everything the launcher needs for first boot
// without requiring the registration token.
//
// The password field is a random one-time password generated by
// "bureau machine provision". The launcher logs in with it, then
// immediately rotates to a locally-derived permanent password. After
// rotation, the one-time password is useless even if the config file
// is captured.
type Config struct {
	// HomeserverURL is the Matrix homeserver base URL
	// (e.g., "http://matrix.internal:6167").
	HomeserverURL string `json:"homeserver_url"`

	// ServerName is the Matrix server name for constructing user IDs
	// (e.g., "bureau.local").
	ServerName string `json:"server_name"`

	// MachineName is the machine's fleet-scoped localpart
	// (e.g., "bureau/fleet/prod/machine/worker-01"). Validated with
	// ref.ParseMachine using the ServerName field.
	MachineName string `json:"machine_name"`

	// Password is the one-time password for initial login. Generated
	// randomly by "bureau machine provision" and rotated immediately
	// by the launcher on first boot.
	Password string `json:"password"`

	// FleetPrefix is the fleet prefix for this machine
	// (e.g., "bureau/fleet/prod"). The launcher uses this to resolve
	// fleet-scoped rooms (machine, service, fleet config) at first boot.
	FleetPrefix string `json:"fleet_prefix"`
}

// Validate checks that all required fields are present and that the
// machine name is a valid Bureau localpart.
func (config *Config) Validate() error {
	if config.HomeserverURL == "" {
		return fmt.Errorf("bootstrap config: homeserver_url is required")
	}
	if config.ServerName == "" {
		return fmt.Errorf("bootstrap config: server_name is required")
	}
	if config.MachineName == "" {
		return fmt.Errorf("bootstrap config: machine_name is required")
	}
	if _, err := ref.ParseMachine(config.MachineName, config.ServerName); err != nil {
		return fmt.Errorf("bootstrap config: invalid machine_name: %w", err)
	}
	if config.Password == "" {
		return fmt.Errorf("bootstrap config: password is required")
	}
	if config.FleetPrefix == "" {
		return fmt.Errorf("bootstrap config: fleet_prefix is required")
	}
	if _, err := ref.ParseFleet(config.FleetPrefix, config.ServerName); err != nil {
		return fmt.Errorf("bootstrap config: invalid fleet_prefix: %w", err)
	}
	return nil
}

// WriteConfig writes a bootstrap config to a file with 0600 permissions.
// The file contains the one-time password, so it must not be
// world-readable.
func WriteConfig(path string, config *Config) error {
	if err := config.Validate(); err != nil {
		return err
	}

	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return fmt.Errorf("bootstrap config: marshal failed: %w", err)
	}
	data = append(data, '\n')

	if err := os.WriteFile(path, data, 0600); err != nil {
		return fmt.Errorf("bootstrap config: write to %s failed: %w", path, err)
	}
	return nil
}

// ReadConfig reads and validates a bootstrap config from a file.
func ReadConfig(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("bootstrap config: read %s failed: %w", path, err)
	}

	var config Config
	if err := json.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("bootstrap config: parse %s failed: %w", path, err)
	}

	if err := config.Validate(); err != nil {
		return nil, err
	}
	return &config, nil
}

// WriteToStdout writes a bootstrap config as formatted JSON to stdout.
// Used by "bureau machine provision" when no --output flag is given.
func WriteToStdout(config *Config) error {
	if err := config.Validate(); err != nil {
		return err
	}

	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return fmt.Errorf("bootstrap config: marshal failed: %w", err)
	}
	data = append(data, '\n')

	_, err = os.Stdout.Write(data)
	return err
}
