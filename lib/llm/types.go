// Copyright 2026 The Bureau Authors
// SPDX-License-Identifier: Apache-2.0

package llm

import "encoding/json"

// Role identifies the speaker in a conversation turn.
type Role string

const (
	// RoleUser is a message from the human or system invoking the model.
	RoleUser Role = "user"

	// RoleAssistant is a message generated by the model.
	RoleAssistant Role = "assistant"
)

// ContentType discriminates the variant of a [ContentBlock].
type ContentType string

const (
	// ContentText is a plain text content block.
	ContentText ContentType = "text"

	// ContentToolUse is a tool invocation requested by the model.
	ContentToolUse ContentType = "tool_use"

	// ContentToolResult is the result of a tool invocation, provided
	// by the caller in a subsequent user message.
	ContentToolResult ContentType = "tool_result"

	// ContentServerToolUse is a server-initiated tool invocation
	// (e.g., Anthropic's tool search). These are managed by the
	// provider's API, not by the agent loop. They flow through
	// conversation history so subsequent requests see them, but
	// are not returned by [Response.ToolUses].
	ContentServerToolUse ContentType = "server_tool_use"

	// ContentServerToolResult is the result of a server-initiated
	// tool invocation. Paired with ContentServerToolUse in the
	// conversation history.
	ContentServerToolResult ContentType = "server_tool_result"
)

// ContentBlock is a single unit of content within a [Message].
// Exactly one of the typed fields is meaningful, determined by Type.
type ContentBlock struct {
	Type             ContentType
	Text             string            // Set when Type is ContentText.
	ToolUse          *ToolUse          // Set when Type is ContentToolUse.
	ToolResult       *ToolResult       // Set when Type is ContentToolResult.
	ServerToolUse    *ServerToolUse    // Set when Type is ContentServerToolUse.
	ServerToolResult *ServerToolResult // Set when Type is ContentServerToolResult.
}

// TextBlock creates a text content block.
func TextBlock(text string) ContentBlock {
	return ContentBlock{Type: ContentText, Text: text}
}

// ToolUseBlock creates a tool-use content block.
func ToolUseBlock(id, name string, input json.RawMessage) ContentBlock {
	return ContentBlock{
		Type:    ContentToolUse,
		ToolUse: &ToolUse{ID: id, Name: name, Input: input},
	}
}

// ToolResultBlock creates a tool-result content block.
func ToolResultBlock(toolUseID, content string, isError bool) ContentBlock {
	return ContentBlock{
		Type:       ContentToolResult,
		ToolResult: &ToolResult{ToolUseID: toolUseID, Content: content, IsError: isError},
	}
}

// ToolUse represents a tool invocation requested by the model.
type ToolUse struct {
	ID    string          // Provider-assigned identifier for this invocation.
	Name  string          // Tool name matching a [ToolDefinition.Name].
	Input json.RawMessage // Tool arguments as a JSON object.
}

// ToolResult carries the output of a tool invocation back to the model.
type ToolResult struct {
	ToolUseID string // Matches [ToolUse.ID] from the preceding assistant turn.
	Content   string // Tool output text (typically JSON for structured tools).
	IsError   bool   // True if the tool invocation failed.
}

// ServerToolUse represents a server-initiated tool invocation
// (e.g., Anthropic's tool_search_tool). These are transparent to
// the agent loop — the provider's API handles them internally —
// but they must flow through conversation history so subsequent
// requests maintain the correct message sequence.
type ServerToolUse struct {
	ID    string          // Provider-assigned identifier.
	Name  string          // Server tool name (e.g., "tool_search_tool_bm25_20251119").
	Input json.RawMessage // Server tool arguments.
}

// ServerToolResult carries the result of a server-initiated tool
// invocation. Paired with a preceding [ServerToolUse] in the
// conversation history.
type ServerToolResult struct {
	ToolUseID string          // Matches [ServerToolUse.ID].
	Content   json.RawMessage // Result content (provider-specific JSON structure).
}

// Message is a single turn in a conversation.
type Message struct {
	Role    Role
	Content []ContentBlock
}

// UserMessage creates a user message with a single text block.
func UserMessage(text string) Message {
	return Message{Role: RoleUser, Content: []ContentBlock{TextBlock(text)}}
}

// AssistantMessage creates an assistant message with a single text block.
func AssistantMessage(text string) Message {
	return Message{Role: RoleAssistant, Content: []ContentBlock{TextBlock(text)}}
}

// ToolResultMessage creates a user message containing tool results.
// This is the internal representation; each provider converts to its
// wire format. Anthropic sends tool results as content blocks in a
// user-role message. OpenAI sends them as separate role:"tool"
// messages (see toOpenAIUserMessages).
func ToolResultMessage(results ...ToolResult) Message {
	blocks := make([]ContentBlock, len(results))
	for i, result := range results {
		blocks[i] = ContentBlock{
			Type:       ContentToolResult,
			ToolResult: &result,
		}
	}
	return Message{Role: RoleUser, Content: blocks}
}

// ToolDefinition describes a tool the model can invoke.
type ToolDefinition struct {
	Name        string          // Unique tool name.
	Description string          // Human-readable description of what the tool does.
	InputSchema json.RawMessage // JSON Schema object describing the tool's parameters.

	// Type is set for provider-managed special tools like Anthropic's
	// "tool_search_tool_bm25_20251119". Empty for regular user-defined
	// tools. When Type is set, the tool is sent with its type field and
	// the provider handles it internally — Description and InputSchema
	// are omitted from the wire format.
	Type string

	// DeferLoading marks this tool for on-demand discovery by the
	// provider's server-side tool search. The tool definition is sent
	// in the request but hidden from the model's context until a
	// search query matches it. Only meaningful for providers that
	// support server-side tool search (Anthropic with the
	// advanced-tool-use beta).
	DeferLoading bool
}

// Request is a provider-agnostic LLM completion request.
type Request struct {
	// Model is the model identifier (e.g., "claude-sonnet-4-5-20250929",
	// "gpt-4o"). Required.
	Model string

	// System is the system prompt. Providers that support system prompts
	// as a dedicated field (Anthropic) use it directly; providers that
	// use a system-role message (OpenAI) prepend it to the messages.
	System string

	// Messages is the conversation history. Must alternate between user
	// and assistant roles, starting with user.
	Messages []Message

	// Tools is the set of tools available to the model. When non-empty,
	// the model may respond with ContentToolUse blocks.
	Tools []ToolDefinition

	// MaxTokens is the maximum number of output tokens. Required by
	// most providers.
	MaxTokens int

	// Temperature controls randomness. nil means provider default.
	Temperature *float64

	// StopSequences are strings that cause the model to stop generating.
	StopSequences []string

	// ExtraHeaders are provider-specific HTTP headers added to the
	// request. For Anthropic, "anthropic-beta" enables features like
	// server-side tool search. Other providers may use this for
	// similar per-request feature flags.
	ExtraHeaders map[string]string
}

// StopReason indicates why the model stopped generating.
type StopReason string

const (
	// StopReasonEndTurn means the model finished its response naturally.
	StopReasonEndTurn StopReason = "end_turn"

	// StopReasonToolUse means the model wants to invoke one or more tools.
	StopReasonToolUse StopReason = "tool_use"

	// StopReasonMaxTokens means the response was truncated at the token limit.
	StopReasonMaxTokens StopReason = "max_tokens"

	// StopReasonStopSequence means a stop sequence was encountered.
	StopReasonStopSequence StopReason = "stop_sequence"
)

// Usage tracks token consumption for a request.
type Usage struct {
	InputTokens      int64
	OutputTokens     int64
	CacheReadTokens  int64
	CacheWriteTokens int64
}

// Response is a complete model response.
type Response struct {
	// Content is the sequence of content blocks in the response.
	Content []ContentBlock

	// StopReason indicates why generation stopped.
	StopReason StopReason

	// Usage is the token consumption for this request.
	Usage Usage

	// Model is the actual model that served the request. May differ
	// from the requested model (e.g., when using model aliases).
	Model string
}

// TextContent returns the concatenated text from all text content blocks
// in the response. Useful when you only care about the text output and
// not tool calls.
func (response *Response) TextContent() string {
	var text string
	for _, block := range response.Content {
		if block.Type == ContentText {
			text += block.Text
		}
	}
	return text
}

// ToolUses returns all tool-use blocks from the response.
func (response *Response) ToolUses() []ToolUse {
	var uses []ToolUse
	for _, block := range response.Content {
		if block.Type == ContentToolUse && block.ToolUse != nil {
			uses = append(uses, *block.ToolUse)
		}
	}
	return uses
}

// StreamEventType identifies the kind of event in a streaming response.
type StreamEventType string

const (
	// EventTextDelta carries incremental text output.
	EventTextDelta StreamEventType = "text_delta"

	// EventContentBlockDone signals that a content block is complete.
	// The finished block is in StreamEvent.ContentBlock.
	EventContentBlockDone StreamEventType = "content_block_done"

	// EventDone signals that the stream is complete. After receiving
	// this event, call [EventStream.Response] for the accumulated result.
	EventDone StreamEventType = "done"

	// EventError carries a stream-level error from the provider.
	EventError StreamEventType = "error"

	// EventPing is a keepalive signal with no payload.
	EventPing StreamEventType = "ping"
)

// StreamEvent is a single event from a streaming model response.
type StreamEvent struct {
	// Type identifies which fields are populated.
	Type StreamEventType

	// Text is the incremental text content. Set for EventTextDelta.
	Text string

	// ContentBlock is the completed content block. Set for
	// EventContentBlockDone.
	ContentBlock ContentBlock

	// Error is the error detail. Set for EventError.
	Error error
}
