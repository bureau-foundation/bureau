#!/bin/bash
# Copyright 2026 The Bureau Authors
# SPDX-License-Identifier: Apache-2.0

# Lists active Bureau agent worktrees and their status.
#
# Usage: bureau-worktree-list [options] [pattern...]
#
# Examples:
#   bureau-worktree-list
#   bureau-worktree-list agent/*
#   bureau-worktree-list --json agent/alice/*

set -euo pipefail

# Colors.
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

info() { printf "${GREEN}[bureau-worktree]${NC} %s\n" "$1"; }
warn() { printf "${YELLOW}[bureau-worktree]${NC} %s\n" "$1"; }
error() { printf "${RED}[bureau-worktree]${NC} %s\n" "$1" >&2; }
header() { printf "${CYAN}[bureau-worktree]${NC} %s\n" "$1"; }

show_help() {
    cat << 'EOF'
bureau-worktree-list - List active Bureau agent worktrees

USAGE
    bureau-worktree-list [options] [pattern...]

ARGUMENTS
    pattern         Glob pattern to filter worktrees (can specify multiple)
                    Patterns match against relative worktree path.

OPTIONS
    -q, --quiet         Minimal output (just paths, no header)
    --json              Output as JSON array (for scripting/agents)
    --complete-only     Show only complete worktrees
    --incomplete-only   Show only incomplete worktrees
    -h, --help          Show this help

ENVIRONMENT
    BUREAU_ROOT     Base directory for Bureau (default: ~/.cache/bureau)
                    Worktrees are in: $BUREAU_ROOT/worktrees/

OUTPUT
    Lists all active worktrees with:
        WORKTREE    Relative path under $BUREAU_ROOT/worktrees/
        BRANCH      Current git branch
        LAST ACTIVITY   Time since last commit (relative)

EXAMPLES
    bureau-worktree-list
        Shows all worktrees with status

    bureau-worktree-list agent/*
        Shows all agent worktrees

    bureau-worktree-list agent/alice/*
        Shows all of alice's worktrees

    bureau-worktree-list agent/*/issue/*
        Shows all issue-based worktrees

    bureau-worktree-list --json agent/*
        JSON output filtered to agents

SEE ALSO
    bureau-worktree-init      Create new worktree
    bureau-worktree-deinit    Remove worktree
EOF
}

# Parse arguments.
QUIET=false
JSON_OUTPUT=false
COMPLETE_ONLY=false
INCOMPLETE_ONLY=false
declare -a FILTERS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -q|--quiet)
            QUIET=true
            shift
            ;;
        --json)
            JSON_OUTPUT=true
            shift
            ;;
        --complete-only)
            COMPLETE_ONLY=true
            shift
            ;;
        --incomplete-only)
            INCOMPLETE_ONLY=true
            shift
            ;;
        -*)
            error "Unknown option: $1"
            show_help
            exit 1
            ;;
        *)
            # Positional argument = filter pattern.
            FILTERS+=("$1")
            shift
            ;;
    esac
done

# Check if path matches any filter pattern (glob-style).
# Returns 0 (true) if matches, 1 (false) otherwise.
matches_filter() {
    local path="$1"
    # No filters = match everything.
    if [ ${#FILTERS[@]} -eq 0 ]; then
        return 0
    fi
    # Match against any pattern (OR semantics).
    for pattern in "${FILTERS[@]}"; do
        # Use bash extended globbing for pattern matching.
        # shellcheck disable=SC2053
        if [[ "$path" == $pattern ]]; then
            return 0
        fi
    done
    return 1
}

# Configuration (same as other worktree scripts).
if [ -n "${BUREAU_ROOT:-}" ]; then
    : # Use env var as-is
else
    BUREAU_ROOT="$HOME/.cache/bureau"
fi
WORKTREES_ROOT="$BUREAU_ROOT/worktrees"

# Check if worktrees directory exists.
if [ ! -d "$WORKTREES_ROOT" ]; then
    if [ "$QUIET" = true ]; then
        exit 0
    fi
    if [ "$JSON_OUTPUT" = true ]; then
        echo "[]"
        exit 0
    fi
    echo "No active agent worktrees in $WORKTREES_ROOT"
    exit 0
fi

# Find all worktrees by looking for .git files (worktrees have a .git file, not directory).
# This finds actual git worktrees, not just any directories.
WORKTREE_PATHS=()
while IFS= read -r -d '' gitfile; do
    worktree_dir=$(dirname "$gitfile")
    WORKTREE_PATHS+=("$worktree_dir")
done < <(find "$WORKTREES_ROOT" -name ".git" -type f -print0 2>/dev/null)

# Check if any worktrees found.
if [ ${#WORKTREE_PATHS[@]} -eq 0 ]; then
    if [ "$QUIET" = true ]; then
        exit 0
    fi
    if [ "$JSON_OUTPUT" = true ]; then
        echo "[]"
        exit 0
    fi
    echo "No active agent worktrees in $WORKTREES_ROOT"
    exit 0
fi

# Get relative time string from timestamp.
relative_time() {
    local timestamp="$1"
    local now
    now=$(date +%s)
    local diff=$((now - timestamp))

    if [ $diff -lt 60 ]; then
        echo "just now"
    elif [ $diff -lt 3600 ]; then
        local minutes=$((diff / 60))
        if [ $minutes -eq 1 ]; then
            echo "1 minute ago"
        else
            echo "$minutes minutes ago"
        fi
    elif [ $diff -lt 86400 ]; then
        local hours=$((diff / 3600))
        if [ $hours -eq 1 ]; then
            echo "1 hour ago"
        else
            echo "$hours hours ago"
        fi
    elif [ $diff -lt 604800 ]; then
        local days=$((diff / 86400))
        if [ $days -eq 1 ]; then
            echo "1 day ago"
        else
            echo "$days days ago"
        fi
    elif [ $diff -lt 2592000 ]; then
        local weeks=$((diff / 604800))
        if [ $weeks -eq 1 ]; then
            echo "1 week ago"
        else
            echo "$weeks weeks ago"
        fi
    else
        local months=$((diff / 2592000))
        if [ $months -eq 1 ]; then
            echo "1 month ago"
        else
            echo "$months months ago"
        fi
    fi
}

# Check if a worktree is complete.
# Returns JSON: {"isComplete": bool, "reason": "..."}
# Complete = all beads closed (no open or in_progress)
check_completeness() {
    local worktree_path="$1"
    local beads_file="$worktree_path/.beads/issues.jsonl"

    # No beads file = nothing to track, consider complete.
    if [ ! -f "$beads_file" ] || [ ! -s "$beads_file" ]; then
        echo '{"isComplete": true, "reason": "no beads"}'
        return
    fi

    # Count open and in_progress beads.
    local counts
    counts=$(jq -s '{
        open: [.[] | select(.status == "open")] | length,
        inProgress: [.[] | select(.status == "in_progress")] | length
    }' "$beads_file" 2>/dev/null)

    if [ -z "$counts" ]; then
        echo '{"isComplete": true, "reason": "no beads"}'
        return
    fi

    local open_count in_progress_count
    open_count=$(echo "$counts" | jq -r '.open')
    in_progress_count=$(echo "$counts" | jq -r '.inProgress')

    if [ "$open_count" -eq 0 ] && [ "$in_progress_count" -eq 0 ]; then
        echo '{"isComplete": true, "reason": "all beads closed"}'
    else
        local reason=""
        if [ "$open_count" -gt 0 ] && [ "$in_progress_count" -gt 0 ]; then
            reason="$open_count open, $in_progress_count in progress"
        elif [ "$open_count" -gt 0 ]; then
            reason="$open_count open"
        else
            reason="$in_progress_count in progress"
        fi
        echo "{\"isComplete\": false, \"reason\": \"$reason\"}"
    fi
}

# Check if worktree passes completeness filter.
# Returns 0 (true) if should be included, 1 (false) otherwise.
passes_completeness_filter() {
    local worktree_path="$1"

    # No filter = include everything.
    if [ "$COMPLETE_ONLY" = false ] && [ "$INCOMPLETE_ONLY" = false ]; then
        return 0
    fi

    local completeness
    completeness=$(check_completeness "$worktree_path")
    local is_complete
    is_complete=$(echo "$completeness" | jq -r '.isComplete')

    if [ "$COMPLETE_ONLY" = true ] && [ "$is_complete" = "true" ]; then
        return 0
    fi

    if [ "$INCOMPLETE_ONLY" = true ] && [ "$is_complete" = "false" ]; then
        return 0
    fi

    return 1
}

# Collect worktree info.
declare -a WORKTREE_INFO=()

for worktree_path in "${WORKTREE_PATHS[@]}"; do
    # Get relative path from WORKTREES_ROOT.
    relative_path="${worktree_path#"$WORKTREES_ROOT"/}"

    # Apply filter if patterns specified.
    if ! matches_filter "$relative_path"; then
        continue
    fi

    # Apply completeness filter if specified.
    if ! passes_completeness_filter "$worktree_path"; then
        continue
    fi

    if [ "$QUIET" = true ]; then
        echo "$relative_path"
        continue
    fi

    # Get current branch.
    branch=$(git -C "$worktree_path" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

    # Get last commit timestamp.
    last_commit_ts=$(git -C "$worktree_path" log -1 --format=%ct 2>/dev/null || echo "0")
    if [ "$last_commit_ts" = "0" ] || [ -z "$last_commit_ts" ]; then
        last_activity="no commits"
        last_commit_ts="null"
    else
        last_activity=$(relative_time "$last_commit_ts")
    fi

    # Store with timestamp for JSON output.
    WORKTREE_INFO+=("$relative_path|$branch|$last_activity|$last_commit_ts|$worktree_path")
done

# If quiet mode, we already printed paths.
if [ "$QUIET" = true ]; then
    exit 0
fi

# Get beads summary for a worktree as JSON fragment.
# Returns: {"total": N, "open": N, "inProgress": N, "closed": N}
get_beads_summary() {
    local worktree_path="$1"
    local beads_file="$worktree_path/.beads/issues.jsonl"

    if [ ! -f "$beads_file" ] || [ ! -s "$beads_file" ]; then
        echo '{"total": 0, "open": 0, "inProgress": 0, "closed": 0}'
        return
    fi

    # Count beads by status using jq.
    jq -s '{
        total: length,
        open: [.[] | select(.status == "open")] | length,
        inProgress: [.[] | select(.status == "in_progress")] | length,
        closed: [.[] | select(.status == "closed")] | length
    }' "$beads_file" 2>/dev/null || echo '{"total": 0, "open": 0, "inProgress": 0, "closed": 0}'
}

# Get source info from AGENT.md as JSON fragment.
# Returns: {"type": "github_issue", "url": "..."} or null
get_source_info() {
    local worktree_path="$1"
    local agent_file="$worktree_path/AGENT.md"

    if [ ! -f "$agent_file" ]; then
        echo "null"
        return
    fi

    # Look for "GitHub Issue:" line.
    local issue_url
    issue_url=$(grep -m1 "^- GitHub Issue:" "$agent_file" 2>/dev/null | sed 's/^- GitHub Issue: *//' | tr -d ' ')

    if [ -n "$issue_url" ]; then
        # Escape for JSON.
        issue_url=$(printf '%s' "$issue_url" | sed 's/\\/\\\\/g; s/"/\\"/g')
        echo "{\"type\": \"github_issue\", \"url\": \"$issue_url\"}"
    else
        echo "null"
    fi
}

# JSON output mode.
if [ "$JSON_OUTPUT" = true ]; then
    echo "["
    first=true
    for info in "${WORKTREE_INFO[@]}"; do
        IFS='|' read -r worktree branch activity timestamp path <<< "$info"
        if [ "$first" = true ]; then
            first=false
        else
            echo ","
        fi
        # Escape strings for JSON (handle quotes and backslashes).
        worktree_json=$(printf '%s' "$worktree" | sed 's/\\/\\\\/g; s/"/\\"/g')
        branch_json=$(printf '%s' "$branch" | sed 's/\\/\\\\/g; s/"/\\"/g')
        path_json=$(printf '%s' "$path" | sed 's/\\/\\\\/g; s/"/\\"/g')
        activity_json=$(printf '%s' "$activity" | sed 's/\\/\\\\/g; s/"/\\"/g')

        # Get beads summary, source info, and completeness.
        beads_json=$(get_beads_summary "$path")
        source_json=$(get_source_info "$path")
        completeness_json=$(check_completeness "$path")

        printf '  {"worktree": "%s", "branch": "%s", "path": "%s", "lastCommitTimestamp": %s, "lastActivity": "%s", "beads": %s, "source": %s, "completeness": %s}' \
            "$worktree_json" "$branch_json" "$path_json" "$timestamp" "$activity_json" "$beads_json" "$source_json" "$completeness_json"
    done
    echo ""
    echo "]"
    exit 0
fi

# Calculate column widths.
max_worktree_len=8  # "WORKTREE"
max_branch_len=6    # "BRANCH"

for info in "${WORKTREE_INFO[@]}"; do
    IFS='|' read -r worktree branch activity _ _ <<< "$info"
    if [ ${#worktree} -gt "$max_worktree_len" ]; then
        max_worktree_len=${#worktree}
    fi
    if [ ${#branch} -gt "$max_branch_len" ]; then
        max_branch_len=${#branch}
    fi
done

# Add some padding.
max_worktree_len=$((max_worktree_len + 2))
max_branch_len=$((max_branch_len + 2))

# Print header.
printf "${BOLD}%-${max_worktree_len}s %-${max_branch_len}s %s${NC}\n" "WORKTREE" "BRANCH" "LAST ACTIVITY"

# Print worktrees.
for info in "${WORKTREE_INFO[@]}"; do
    IFS='|' read -r worktree branch activity _ _ <<< "$info"
    printf "%-${max_worktree_len}s %-${max_branch_len}s %s\n" "$worktree" "$branch" "$activity"
done
